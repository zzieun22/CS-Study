# What you must know 

## 디자인 패턴(Design Pattern) 이란?

소프트웨어 디자인에서 계속 재현되는 문제를 해결하는 재사용 가능한 해결법이다.  

ex> 문제 '특정 클래스가 실행간에 단 한번만 인스턴스화 되어 객체로 이용가능 하여야한다.'를 해결하기 위해 '싱글톤 디자인패턴'을 이용해 볼 수있다'  

또는 특정 클래스의 생성 또는 객체화에 있어 호출당시의 콘텍스트(Context)를 고려하여 클래스를 반환해주는 “팩토리 디자인패턴(Factory Design Pattern)” 을 사용할 수 있다.  

이렇게 디자인 패턴은 디자인(설계)간에 발생하는 문제를 해결해주는 해법 이라고 볼 수 있다. 디자인패턴은 데이터구조, 알고리즘과 다르며 아주 특정한 구조에서 특정한 문제에 한하여 한번만 문제를 해결 할 수 있는 디자인은 "디자인 패턴"이라고 보기 어렵다.(재사용이 가능해야 한다.)    

조금 더 쉽게 말해 디자인 패턴(Design Pattern)은  문제/의도/해결방법이 명시적입니다. 즉 해당 패턴이 사용되는 문제가 “정형화” 되어 있으며, 해당 문제를 접근하는데 어떠한 의도를 가지고 어떻게 해결하는지에 대해서 명시적인 해결 방법 또는 접근 방법을 제안한다.


## Singleton 패턴

``` Singleton패턴 ```이란? 애플리케이션에서 인스턴스를 하나만 만들어 사용하기 위한 패턴이다. 커넥션 풀, 스레드 풀, 디바이스 설정 객체 등의 경우, 인스턴스를 여러 개 만들게 되면 자원을 낭비하게 되거나 버그를 발생시킬 수 있으므로 오직 하나만 생성하고 그 인스턴스를 사용하도록 하는 것이 이 패턴의 목적이다

### 구현

[singleton 패턴 구현](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DesignPattern)

## C++의 디자인 패턴_경량패턴

하나의 클래스당 필요한 데이터가 너무 많고 크기도 클때, 1프레인에 GPU로 모두 전달하기에는 양이 너무 많다.  


class Tree {
private:
Mesh mesh; // 메시     
Texture bark; // 나무껍질 텍스처 
Texture leaves; // 잎사귀 텍스처 
Vector position;
double height;
double thickness;
Color barTint;
Color leafTint;
};

이것을해결하기위해 ->  
객체에 들어있는 데이터 대부분이 인스턴스별로 다르지 않다면?  그 객체를 반으로 쪼개어 명시적으로 모델링 할 수 있다.   

모든 클래스가 다 같이 사용하는 데이터를 뽑아내 새로운 클래스를 만들 수 있다.   


class TreeModel {
private:
Mesh mesh;
Texture bark;
Texture leaves;
};

그럼 이 TreeModel 객체는 하나만 존재하게 된다. 그 이후 각 인스턴스들은 공유객체인 TreeModel을 참조하기만 하면된다. 

class Tree {  
private: 
TreeModel * model;
Vector position; 
double height; 
double thickness; 
Color barkTint; 
Color leafTint; 
}

-----
GPU로 보내는 데이터 양을 최소화하기 위해서는 공유 데이터인 TreeModel을 딱 한 번만 보낼 수 있어야 한다. 그 후 각각 인스턴스마다의 데이터를 전달하고 마지막으로 GPU에 '전체 인스턴스를 그릴 공유데이터를 사용해' 라고 말하면 된다. 

### 경량패턴
이름에서 알 수 있듯이 **경량 패턴은 어떤 객체의 개수가 너무 많아서 좀 더 가볍게 만들고 싶을 때** 사용 한다. 인스턴스 렌더링에서는 메모리 크기보다 렌더링할 나무 데이터를 하나씩 GPU 버스로 보내는 데 걸리는 시간이 중요하지만, 기본 개념은 경량 패턴과 같다.

경량 패턴은 객체 데이터를 두 종류로 나눈다. 먼저 모든 객체의 데이터 값이 같아서 공유할 수 있는 데이터를 모은다. 이런 데이터를 GoF는 고유 상태 또는 자유 문맥 상태라고 부른다. 예제에서는 나무 형태나 텍스처가 이에 해당한다.  
나머지 데이터는 인스턴스별로 값이 다른 외부 상태에 해당한다. 예제에서는 나무의 위치, 크기, 색 등이 이에 해당한다.

[경량패턴](http://boycoding.tistory.com/106)


## Map/HashMap/TreeMap/Hashtable 등의 차이점



**Map**

Map은 key와 value를 가진 집합이며, 중복을 허용하지 않는다.  

즉, 한개의 key에 한개의 value가 매칭된다.  

java.util 패키지에 여러 집합들을 사용하기 위한 여러 interface와 class 들이 정의되어 있다.



**HashMap**

HashMap은 Map interface를 implements 한 클래스로서 중복을 허용하지 않는다.  Map의 특징인 key와 value의 쌍으로 이루어지며, key 또는 value 값으로써 null을 허용한다. 

내부적으로 Entry<K,V>[] Entry 의 array 로 되어 있다. 해당 array 에 index 는 내부 해쉬 함수를 통해 계산된다.

String 은 sun.misc.Hashing.stringHash32 함수를 사용하고 일반 Object는 내부 hashcode 함수와 비트연산으로 계산되어진다.

1 Map<String, String> map = Maps.newHashMap();

2 map.put("c", "1");

3 map.put("a", "1");

4 map.put("b", "1");

5 map.put("k", "1");

6 for (String s : map.keySet()) {

7     System.out.println(s);

8 }

9 // b, c, a, k 출력

내부 hash 값에 따라서 키순서가 정해지므로 특정 규칙없이 출력됨!

```
public class HashMapTest 
{ 
    public static void main(String argv[]) 
    { 
        HashMap hm = new HashMap(); 
        System.out.println(hm.put("aaa", "111")); 
        System.out.println(hm.put("bbb", "222")); 
        System.out.println(hm.put("aaa", "444")); 
        System.out.println(hm.put("ccc", "333"));     
        System.out.println(hm.put("ccc", null));        
         
        System.out.println("HashMap size : " + hm.size()); 
         
        Set set = hm.keySet(); 
        Object []hmKeys = set.toArray(); 
        for(int i = 0; i < hmKeys.length; i++) 
        { 
            String key = (String)hmKeys[i];    
            System.out.print(key); 
            System.out.print(" - "); 
            System.out.println((String)hm.get(key)); 
        } 
    } 
} 
/*
실행:java HashMapTest 
결과: 
null 
null 
111 
null 
333 
HashMap size : 3 
ccc - null 
bbb - 222 
aaa - 444 
*/
```



**Hashtable**

 Hashtable Map interface를 implements 한 클래스로서 중복을 허용하지 않는다.  Map의 특징인 key와 value의 쌍으로 이루어지며, key 또는 value 값으로써 null을 허용하지 않는다.(HashMap과의 차이점)   아래의 예는 HashTable을 사용한 간단한 예제이다. 

```
public class HashtableTest 
{ 
    public static void main(String argv[]) 
    { 
        Hashtable ht = new Hashtable(); 
        System.out.println(ht.put("aaa", "111")); 
        System.out.println(ht.put("bbb", "222")); 
        System.out.println(ht.put("aaa", "444")); 
        System.out.println(ht.put("ccc", "333"));     
         
        System.out.println("Hashtable size : " + ht.size()); 
         
        System.out.println("aaa value : " + (String)ht.get("aaa"); 
         
    } 
} 
/** 
실행:java HashMapTest 
결과: 
null 
null 
111 
null 
Hashtable size : 3 
aaa value : 444 
*/    
```

| 기능                          | HashMap | HashTable |
| ----------------------------- | ------- | --------- |
| 키나 값에 null 저장 가능 여부 | O       | X         |
| 여러 쓰레드 안전 여부         | X       | O         |



**TreeMap**

TreeMap역시 중복을 허용하지 않으며, key와 value의 쌍으로 이루어져 있다.   HashMap과 다른 점은 SortedMap을 implements 하였으므로, key 값들에 대한 정렬이 이루어진다는 점이다.  

내부적으로 RedBlack Tree로 저장됨, 키값에 대한 Compartor 구현으로 정렬 순서를 바꿀수 있다.

1 Map<String, String> map = Maps.newTreeMap();

2 map.put("c", "1");

3 map.put("a", "1");

4 map.put("b", "1");

5 map.put("k", "1");

6 for (String s : map.keySet()) {

7     System.out.println(s);

8 }

9 // a, b, c, k 출력

키값이 알파벳 순서대로 정렬된다. 트리에 저장되므로 키값은 일정 기준으로 정렬된 상태로 출력된다.

```
import java.util.*; 

public class Freq { 
    private static final Integer ONE = new Integer(1); 

    public static void main(String args[]) { 
        Map m = new TreeMap(); 

        // Initialize frequency table from command line 
        for (int i=0; i < args.length; i++) { 
            Integer freq = (Integer) m.get(args[i]); 
            m.put(args[i], (freq==null ? ONE : 
                            new Integer(freq.intValue() + 1))); 
        } 

        System.out.println(m.size()+" distinct words detected:"); 
        System.out.println(m); 
    } 
} 
/** 
실행:java Freq if it is to be it is up to me to delegate 
결과: 
8 distinct words detected: 
{be=1, delegate=1, if=1, is=2, it=2, me=1, to=3, up=1} 
*/    
  
```



**LinkedHashMap**

링크드 리스트로 저장됨

1 Map<String, String> map = Maps.newLinkedHashMap();

2 map.put("c", "1");

3 map.put("a", "1");

4 map.put("b", "1");

5 map.put("k", "1");

6 for (String s : map.keySet()) {

7     System.out.println(s);

8 }

9 // c, a, b, k 출력

키값은 입력 순서대로 출력되어서 나온다.



**HashMap과 TreeMap의 주요 차이점 **

1. HashMap은 어떤 순서도 유지하지 않습니다. 즉, HashMap는, 최초로 삽입 된 요소가 최초로 인쇄되는 것을 보증하지 않습니다. TreeSet와 같이, TreeMap 요소도 요소의 자연 순서 부에 따라 소트됩니다
2. 내부 HashMap 구현은 Hashing을 사용하고 TreeMap은 Red-Black 트리 구현을 내부적으로 사용합니다.
3. HashMap은 하나의 null 키와 많은 null values를 저장할 수 있습니다. TreeMap은 null 키를 포함 할 수 없지만 많은 null 값을 포함 할 수 있습니다.
4. HashMap은 O (1)과 같은 get과 put 같은 기본 연산에 대해 일정한 시간 성능을 나타냅니다. 오라클 문서에 따르면 TreeMap은 get 및 put 메소드에 대한 log (n) 시간 보장 비용을 제공합니다.
5. HashMap의 성능 시간은 대부분의 작업에서 TreeMap에 대해 일정하므로 HashMap은 TreeMap보다 훨씬 빠릅니다.
6. HashMap은 비교에서 equals () 메소드를 사용하지만 TreeMap은 ordering을 유지하기 위해 compareTo () 메소드를 사용합니다.
7. HashMap은 Map 인터페이스를 구현하고 TreeMap은 NavigableMap 인터페이스를 구현합니다.



**HashMap**

1. `HashMap` 에는 키를 기반으로하는 값이 들어 있습니다.

2. 고유 한 요소 만 포함합니다.

3. 하나의 널 (null) 키와 복수의 널 값을 가질 수 있습니다.

4. 그것은 **순서를** 유지 **하지 않습니다** .

   `public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable`

**LinkedHashMap**

1. `LinkedHashMap` 에는 키를 기반으로 한 값이 들어 있습니다.

2. 고유 한 요소 만 포함합니다.

3. 하나의 널 (null) 키와 복수의 널 값을 가질 수 있습니다.

4. 대신 **삽입 순서** 를 유지 관리하는 HashMap과 동일합니다. *// 아래 클래스 감속을 참조하십시오.*

   `public class LinkedHashMap<K,V> extends HashMap<K,V> implements Map<K,V>`

**TreeMap**

1. `TreeMap` 에는 키를 기반으로 한 값이 들어 있습니다. NavigableMap 인터페이스를 구현하고 AbstractMap 클래스를 확장합니다.

2. 고유 한 요소 만 포함합니다.

3. null 키는 가질 수 없지만 복수의 널 값을 가질 수 있습니다.

4. 그것은 `HashMap` 과 마찬가지로 **오름차순** 을 유지합니다 (키의 자연 순서를 사용하여 정렬 됨).

   `public class TreeMap<K,V> extends AbstractMap<K,V> implements NavigableMap<K,V>, Cloneable, Serializable`

**Hashtable**

1. Hashtable은 목록의 배열입니다. 각 목록을 버킷이라고합니다. 버킷의 위치는 hashcode () 메소드를 호출하여 식별됩니다. Hashtable에는 키를 기반으로하는 값이 들어 있습니다.
2. 고유 한 요소 만 포함합니다.
3. null 키나 값이없는 경우가 있습니다.
4. 그것은 **동기화** 됩니다.
5. 그것은 레거시 수업입니다.



**결론**

- 특별한 이유가 없다면 검색 성능이 좋은(O(1)) HashMap 을 사용하자
- 키값이 일정한 수준대로 iterate 하려고 한다면 TreeMap 을 사용하자.  하지만 랜덤 접근에 대해서는 O(logn) 성능을 지니므로 많은 데이터를 넣을경우 좋지 않은 성능이 나올수 있다.
- 입력 순서가 의미있다면 LinkedHashMap 을 사용하자. 랜덤 접근에 대해 O(n) 성능을 지니므로 많은 데이터를 입력할 경우 사용하지 않는것이 좋겠다.

## 운영체제 

### 프로세스

**Multiprogramming

다중프로세스를 활용하는 다중 프로그래밍 시스템이다. 메인 메모리에 여러 가지 프로세스를 올려 작업을 처리할 수 있게 해주는 시스템이다. 프로세스의 종류 중에는 I/O와 같이 Device를 주로 사용하는 프로세스가 있을 수 있고 CPU를 주로 사용하는 프로세스가 있을 수 있다. 그런데 메인 메모리로 올라오는 프로세스의 종료가 한 쪽으로 치우친다면 프로세스를 처리하는데 사용되는 시간이 매우 오래 걸리게 될 것이다. 그래서 Job scheduler에서는 두 종류의 프로세스를 적절히 조화를 시켜 메인 메모리에 올린다.   

다중 프로그래밍 시스템에서 가장 중요한 작업은 메모리에 있는 안 쓰는 프로세스는 하드디스크로 보내고 다시 사용하는 프로그램은 적절하게 메인 메모리로 올리는 작업을 진행하여야 한다. 이런 작동을 Swapping이라고 한다. 이런 작동을 하기 위해서는 적절한 **문맥전환(Context switching)**이 필수적이다. 그런 역할을 하는 장치들은 Scheduler와 Dispatcher가 있다. Scheduler는 위에 설명하였듯이 선택을 하는 존재이다. 어떤 프로세스가 적절한지에 대한 선택을 **Scheduler**가 진행하며 그에 대한 실행, 할당은 **Dispatcher**가 진행하게 된다.

### 스레드및 프로세스 동기화

스레드는 프로그램 내부에 흐르는 맥, 흐름 이라고 한다. 를 들어 자바나 C로 프로그램을 작성할 때 메인 함수를 통해 각종 표현식이 돌아 프로그램이 끝이 나는 것을 “맥이 흐른다.”라고 한다 .

하지만 한 프로그램에 2개이상의 맥이 흐를 수 있는데 이것을 **다중스레드** 라고 한다. 시간간격이 매우 짧아 동시에 맥이 흐르는 것처럼 보인다.



대부분프로그램은 -> 다중스레드

한 프로세스 내의 다중 스레드는 프로세스의 메모리공간공유, 자원공유도한다. 

모든 프로그램은 메인스레드라는 기본적인 스레드를 가지고 있다. (main 함수)

프로세스 관리에 중요한 역할은 **스케줄링** 과 **동기화**이다. 



**CPU 스케줄링 알고리즘**

우선 **FCFS(First-Come, First-Served)**이다.

말 그대로 먼저 들어온 프로세스를 먼저 실행하는 알고리즘이다. 어떻게 말해서는 가장 간단하고 공정한 알고리즘이 될 수 있지만 평균 대기시간을 비교하는 척도로 하면 좋은 알고리즘이라고 할 수 없다. FCFS는 비선점 스케줄링으로 프로세스가 끝날 때까지 다른 프로세스들이 기다려야한다. FCFS를 이용하게 되면 Convoy effort(호위 효과)를 발생시킬 수 있는데 이 효과는 CPU를 이용하는 시간이 긴 프로세스를 다른 프로세스들이 오래 기다리고 있는 효과로 마치 긴 프로세스를 호위하며 둘러싸고 있다고 해서 이런 이름이 붙여졌다.

다음은 **Shortest-Job-First**이다.

이 알고리즘도 이름에서 유추하듯이 가장 짧은 CPU 할당 시간을 가진 프로세스를 먼저 처리하는 방식이다. 평균 대기시간을 척도로 하면 가장 합리적인 방법이라고 할 수 있다. 하지만 실제로 CPU 할당 시간을 정확하게 알 수 없으므로 예측을 통해 진행해야한다. 이 알고리즘은 선점 방식일수도 있고 비선점 방식일수도 있다.

프로세스에 정수 값인 우선순위를 주어 CPU를 할당할 수 있는 알고리즘도 있다. 우선순위 스케줄링이라고 불리는데 내부적 외부적으로 다양한 조건들을 활용해 프로세스에 우선순위를 부여한다. 숫자가 작을수록 우선순위가 높아진다. 이 알고리즘도 선점 방식일수도 있고 비선점 방식일수도 있다. 하지만 이 알고리즘은 기아라는 프로세스를 발생시킬 수 있다. 이 프로세스는 우선순위가 낮은 프로세스로 계속해서 이 프로세스보다 우선순위가 높은 프로세스가 들어오게 되면 절대로 처리를 할 수 없게 된다. 이런 문제를 해결하기 위해 aging이라는 기법을 사용하는데 우선순위가 낮은 프로세스가 계속 처리를 못하고 있으면 우선순위를 높여주어 처리를 할 수 있게 해준다.

다음은 **Round-Robin**이라는 알고리즘이다. 시분할 시스템에서 사용하는 알고리즘으로 CPU를 할당하는 방법으로 Time quantum을 사용한다. Time quantum은 시간 양자라고 하는데 일정시간을 선정하여 CPU 할당을 모든 프로세스에게 동일하게 분담하는 것이다. 이러한 작업은 모든 프로세스가 동시에 할당되고 있는 것처럼 보이게 된다. 여기서 성능은 시간 양자를 얼마의 사이즈로 잡느냐에 따라 달라진다. 이 알고리즘은 시간 양자에 따라 다른 프로세스로 바꾸어주기 때문에 선점 방식이다.

다음으로는 위와 같은 알고리즘은 아니지만 프로세스의 종류에 따라 다른 level을 두어 스케줄링을 하는 **Multilevel Queue Scheduling**이다. 시스템 프로세스, Interative process, Interactive editing process 등등으로 프로세스 그룹을 나누게 된다. Queue를 여러 개 두어 각 Queue마다 처리하는 프로세스를 다르게 처리한다. Queue에도 우선순위가 존재하며 CPU 시간을 차등으로 배분하게 된다. 각 Queue들은 독립적인 스케줄링 알고리즘을 가지게 된다.

Multilevel Feedback Queue Scheduling도 있는데 Multilevel Queue Scheduling과 같이 복수 개의 Queue를 가지지만 다른 Queue로 점진적으로 이동한다는 점이 다르다. 하나의 입구로 진입하여 너무 많은 CPU time을 사용 시 다른 Queue로 이동하게 되고 기아 상태가 될려고 하면 다시 우선순위가 높은 Queue로 이동하게 된다.

 

### 프로세스 관리 -스케줄링-

CPU스케줄링은 크게 두가지 특징으로 나눌 수 있다. 

**선점하는 방식** & **비선점하는 방식** 

선점하는 방식은 하나의 프로세스가 CPU를 할당받아 작업을 수행하고 있는 도중에 다른 프로세스가 새치기를 할 수 있는 방식이다. 

하지만 비선점하는 방식은 하나의 프로세스가 CPU할당이 끝나야 다른 프로세스가 CPU를 할당 받을 수 있는 형식이다. 선점과 비선점에의해 컴퓨터 성능에 영향을 끼친다.



### 임계구역 문제 및 세마포어

동시에 은행계좌에 업데이트를 하면 문제가 발생할 수 있다. 우리는 한 번에 한 스레드만 업데이트하는 프로세스 동기화가 필요하다. 이러한 문제를 임계구역문제 라고 한다.

EX> 은행계좌문제에서 부모님은 은행계좌에 입금 학생은 출금하는 형식을 가지고있다. 부모님과 학생은 스레드를 의미한다. 은행계좌는 공통적으로 사용하는데이터가 된다. 

**임계구역**을 해결하기위해서 3가지가 만족되어야 한다.

1. **상호배타** -> 한순간에 업데이트는 한스레드만 가능하다
2. **진행**-> 누가 먼저 들어갈지 결정을 유한시간내에 해야한다.
3. **유한대기** -> 스레드가 유한시간내에 접근해야한다. 무한한대기의 경우가 발생해서는 안된다. 





## Semaphore

프로세스/ 스레드 동기화는 여러개의 프로세스/스레드가 공통으로 데이터에 접근하려고 할 때 발생하는 문제를 해결하는 방법이다. 

**세마포어** -> 운영체제 동기화를 위한 도구 중 하나이다.

스레드가 동작하는 공간에는 공통 데이터를 수정할 수 있는 임계구역이 존재한다.  스레드가 동작하면서 임계구역에 들어가게 되면 데이터를 수정할 수 있다. 코드동작도중 acquire()라는 명령어가 실행되면 임계구역에 들어가라는 명령어이므로 스레드가 임계구역에 들어가기된다. release()되면 임계구역 나옴 



문제 -> 스레드가 자신의 임계구역에 들어가서 공통으로 사용하는 데이터를 수정하고 있는 상황에서 **문맥전환** 에 의해 다른 스레드가 자신의 임계구역에 들어가서 공통으로 사용하는 데이터를 수정하려는 시도할 때 **임계구역 문제**가 발생할 수 있다.

발생하지 않게 하는 방법이 **상호배타** 이다. 상호배타를 만족시킬 수 있는 방법은 **세마포** 라는 도구를 통해서 만들어진다. 

*세마포어* 는 정수값을 가지는데 처음에 나타나는 정수는 임계구역에 들어갈 수 있는 스레드 수를 나타낸다. acquire() 명령어를 실행해서 임계구역에 들어가게 되었을 때 문맥 전환에 의해 다른 스레드가 acquire() 명령어를 실행했다고 하더라도 임계구역에 들어갈 수 없게 막는 공간이 세마포어이다.



**동작원리**

세마포 (스레드를 보관하는 Queue를 가진다) 는 정소값을 가짐 ex> (1) -> 임계구역에 접근 가능한 스레드는 하나! 이다.

if 임계구역에 스레드가 존재하지 않을경우 acquire()명령을 실행 할 수 있다. 

-> 세마포는 acquire()명령을 받았으니 1 감소시킴 (정수값이 0보다 작아지면 세마포의 Queue에 스레드를 block 시킨다.)

-> 이 상황은 0이므로 block하지말고 바로 임계구역으로 이동해 명령을 수행한다. 

But 컴퓨터의 CPU할당은 문맥전환에 의해 다른 스레드로 갈수 있음 

if 다른 스레드가 문맥전환에의해 코드가 실행되었다면? 그런데 이 다른 스레드가 또 acquire()명령을 실행한다면? 

-> 두번째 스레드도 임계구역에 들어가고 싶어함 

But 이미 하나의 쓰레드가 임계구역에 존재하고 있으므로 들어가면 안된다. 

이를 제어하는것이 **세마포어**

acquire() 명령이 또 실행되었으니 세마포어 정수값은 -1이 된다. 그럼 0보다 작아져 두번째 스레드는 세마포어의 Queue에 block를 당해 임계구역에 접근하지 못하는 상황이 된다. 

-> 들어가려면 먼저 임계구역에 들어간 스레드가 release()라는 명령어를 통해 +1 시켜주면 대기하고있던 스레드가 wakeup을 통해 세마포어를 탈출할 수 있게 된다. 



이런 방식을 통해 임계구역을 접근할 수 없게 하는 **상호배타** 적용이 가능해진다.



> 세마포는 프로세스 실행순서를 원하는대로 제어하는 역할도 할 수 있다. 



### 프로세스 관리 (생산자 소비자 문제)

생산자-소비자 문제는 생산자가 데이터를 생성하면 소비자는 그것을 소비하는 형태에서 발생하는 문제를 말한다.

일반적으로 생산속도와 소비속도의 차이가 존재한다. 생산속도가 소비하는 속도보다 빨라서 데이터는 바로 소비되지 못한다. 이를 보완하기 위해 생산된 데이터를 보관하는 *버퍼*라는 공간이 존재한다. 버퍼의 크기는 유한하다.(Bounded Buffer) 버퍼가 가득차면 더이상 넣을 수 없고 소비자는 버퍼가 비면 뺄 수 없다.

우선 버퍼에 대한 클래스를 만들어 버퍼를 정수 값으로 지정을 하였다. size는 버퍼의 크기를 나타내고 count는 버퍼에 들어와 있는 데이터의 개수라고 할 수 있다. 생산된 데이터가 버퍼로 들어오면 count를 1증가시키고 소비자가 빼어 가면 1감소시킨다. in은 데이터를 넣는 위치를 out은 빼내는 위치를 가리킨다. in 값은 데이터가 들어올 때마다 1씩 증가하고 out 값은 데이터가 나갈 때마다 1씩 증가한다. 만약 in의 값이 size까지 가게 되면 다시 처음 0의 값으로 돌아가서 데이터를 넣기 시작한다. 버퍼가 가득 차여져 있으면 out이 실행되기 전까지 무한루프를 돌면서 데이터를 넣지 못하고 기다리고 있는 상태가 된다. 반대로 버퍼가 비어져 있으면 out은 실행되지 못하고 무한루프를 돌게 되고 in으로 데이터가 들어오기를 기다리게 된다.

![img](https://t1.daumcdn.net/cfile/tistory/2341DA4158F87CED1E)

생산자와 소비자는 서로 다른 동작을 하는 쓰레드로 제작을 하면 된다. 생산자의 쓰레드의 경우는 N번 데이터를 생산하여 버퍼에 넣어주는 작업을 소비자의 쓰레드는 N번 데이터를 버퍼에서 가져와 소비하는 작업을 만들어 준다. 메인함수에서는 100크기의 버퍼를 만들고 N을 만 번으로 지정한다.

![img](https://t1.daumcdn.net/cfile/tistory/2401654158F87CED1A)

위의 코드를 실행하게 되면 당연히 만 번 데이터가 들어가고 만 번 데이터가 나와 결과적으로 버퍼의 count는 0이 되어야 하는데 실행을 해보면 그렇게 되지 않는 경우가 발생하는 것을 알 수 있다. 또한 실행이 불가한 경우도 발생한다. 이러한 문제가 발생하는 이유가 바로 쓰레드 동기화가 되지 않았기 때문이다. 공통변수인 count, buf에 대한 동시 업데이트가 발생하여 값의 변화에 문제가 생긴다. 공통변수 업데이트 구간인 임계구역에 대한 동시 진입이 가능하므로 데이터의 변화가 따로 발생할 수 있으므로 문제가 발생한다. 다시 말해 생산자가 count를 올리고 있는 도중에 문맥전환에 의해 소비자가 돌게 되어 count를 낮추는 작업을 하게 되면 count의 값에 오류가 발생하는 것이다.

이를 해결하기 위해서는 임계구역에 대한 동시 접근을 방지하는 상호배타의 기능이 추가되어야한다. 우리는 앞장을 통해 상호배타를 적용시킬 수 있는 방법을 알고 있다. 바로 세마포를 이용하여 상호배타를 적용시켜 주는 것이다. 세마포의 정수 값을 1로 두어 생산자나 소비자 중 하나만이 임계구역에 들어갈 수 있도록 해주어야 한다. 이렇게 세마포를 만들게 되면 생산자가 데이터를 생산하여 버퍼에 넣어주는 작업을 수행하게 되면 소비자는 데이터를 빼내는 작업을 할 수 없게 된다. 공통된 값인 count와 buf에 관련된 업데이트가 동시에 되지 않으므로 오류가 발생하지 않는다.

자바 코드에서 수정을 하는 부분은 insert와 remove 공간에서 버퍼의 데이터를 업데이트 해주는 부분을 감싸는 acquire()명령어와 release()명령어를 입력해주면 된다. 물론 세마포에 대한 정의를 따로 해주어야 한다. 우리는 이렇게 세마포를 사용하여 프로세스/쓰레드 동기화를 시켜주어 오류를 수정해 줄 수 있다.

![img](https://t1.daumcdn.net/cfile/tistory/21118D4358F87DD116)

하지만 위의 과정은 오류에 대한 수정은 하였지만 기다려야하는 시간이 길어질 수 있다. 앞의 키워드에서 주어졌듯이 생산자는 버퍼가 가득 차 있으면 기다려야하고 소비자는 버퍼가 비어 있으면 기다려야한다. 코드를 보면 무한루프를 돌면서 계속 CPU가 할당되어 잡혀있는데 이런 시간은 매우 좋지 않다. 이런 기다림을 Busy-wait이라고 한다. CPU가 아무 일도 하지 않게 되면 성능이 매우 낭비가 된다. 이를 해결하는 것도 세마포를 이용해서 할 수 있다. 세마포의 장점 중 하나는 프로세스나 쓰레드의 실행 순서를 사용자가 원하는 순서에 따라 작업을 수행시킬 수 있게 하는 것이다. 만약 버퍼가 가득 차여 있으면 세마포의 공간에 생산자를 가두어 CPU가 할당 받지 못하도록 한다. 이렇게 되면 CPU는 무조건 소비자에게 CPU를 할당할 수밖에 없어 버퍼의 빈 공간을 만들어 주게 된다. 반대로 버퍼가 비어있으면 CPU할당을 생산자에게 주어 버퍼를 채우게 한다.

이러한 세마포를 재작해보자. 위와 같은 동작을 하려면 세마포를 두 개를 재작해야한다. 생산자와 버퍼와의 관계를 제어할 수 있는 세마포(empty)와 소비자와 버퍼의 관계를 제어하는 세마포(full)가 필요하다. 생산자와 버퍼를 제어하는 세마포는 정수 값의 초기 값을 size 값으로 가지게 된다. 데이터가 계속 버퍼에 들어가는데 버퍼가 size만큼 들어가게 되면 생산자는 block이 되어야한다. 반대로 소비자의 세마포는 비어 있을 때 block되어야 하므로 정수 값의 초기 값으로 0을 가진다. 버퍼에 데이터가 들어오면 정수의 값을 증가시키고 데이터가 없는 빈 버퍼가 되었을 때 acquire()명령으로 데이터를 빼내오려고 한다면 정수 값이 0보다 작은 값을 가지게 되므로 소비자 쓰레드를 block 시킨다. 두 개의 세마포는 release를 명령을 보내게 되면 상대방의 세마포를 풀어주어 동작을 할 수 있게 한다. 이렇게 제어를 하게 되면 CPU가 무한 루프를 돌고 있는 작업을 하는 것을 막을 수 있다.

 ![img](https://t1.daumcdn.net/cfile/tistory/2701CC4158F87CEE2C)   

[출처](http://copycode.tistory.com/67?category=740133)

### 읽기쓰기 문제 (식사하는 철학자)

읽기 쓰기 문제는 공통 데이터베이스에 접근하는 문제를 다룬다. 서버에 데이터베이스가 존재하는데 다른 로컬 컴퓨터들이 데이터에 접근을 할 수 있다. 접근하는 사용자 중에는 Reader와 Writer가 존재한다. Reader는 데이터를 읽기만 하는 사용자이고 Writer는 데이터를 읽고 수정할 수 있는 사용자를 의미한다. 데이터베이스를 사용자들이 모두 공통 사용하므로 임계구역이라고 생각할 수 있다.

우리는 앞의 임계구역 문제를 해결하기 위해 동기화를 사용하였는데 상호배타를 만족시키기 만들어 한 번에 한 개의 프로세스만 접근이 가능하게 만들었다. 임계구역에 데이터를 접근하는 사용자에 접근 권한을 두어 동시에 접근을 할 수 없게 만들었다. 하지만 위의 읽기 쓰기 예시를 한 번 살펴보면 이런 점이 매우 비효율적이라는 것을 알 수 있다.

만약 사용자 Reader1이 데이터베이스에 접근을 했는데 다른 Reader2가 데이터베이스에 접근을 한다고 문제가 발생할까? Reader는 데이터를 읽기만 하는 사용자를 의미한다. 따라서 데이터베이스에 접근을 하더라도 데이터의 변형을 만들지 않아 문제를 발생시키지 않는다. 효율성의 제고를 통해 Reader이 동시에 접근하려고 하면 접근 권한을 주어도 된다. 그러면 Writer의 경우는 어떨까? Writer는 데이터를 읽기도 하지만 쓰기도 한다. 즉 데이터의 변형, 업데이트가 일어난다. 따라서 Writer 두 사용자가 동시에 접근하면 문제가 발생할 수 있다. 그러면 Reader가 들어왔는데 Writer가 접근을 하고 싶어 하면 어떻게 될까? Reader가 읽고 있는 데이터가 Writer에 의해 변형, 업데이트 되므로 문제가 발생할 수 있다. Reader는 제대로 된 데이터를 읽을 수 없기 때문이다.

![img](https://t1.daumcdn.net/cfile/tistory/273B225058FAF69035)

그러면 어떻게 설계를 해야 할까?

∙Reader가 데이터베이스(임계구역) 들어갈 경우, 다른 Reader는 접근할 수 있으나 Writer는 접근할 수 없다.

∙Writer가 데이터베이스(임계구역) 들어갈 경우, Reader와 Writer 모두 접근할 수 없다.

 

위의 문제를 해결하기 위해서는 우선순위를 이용하여 해결할 수 있다. Reader에게 먼저 우선권을 주어 Reader가 접근을 하면 Writer는 반드시 다음으로 실행이 되어야한다.

 

식사하는 철학자 문제는 5명의 철학자가 식사를 하고 있는 상황을 가정한 문제이다. 철학자들이 원형의 테이블에 앉아 있는데 철학자들 사이에는 젓가락이 놓여있다. 하지만 젓가락이 한 쌍이 놓여 있는 게 아니라 하나가 놓여있는 상황이다. 철학자는 생각을 하면서 산다. 그러다가 배가 고프면 자신의 양 옆에 있는 젓가락을 사용해서 식사를 하고 또 다시 생각을 한다. 이러한 상황을 가정한 문제가 식사하는 철학자 문제이다. 여기서 어떤 문제가 발생하겠는가? 만약 서로 양 옆에 앉아 있는 철학자 같이 배가 고플 경우 어떻게 되겠는가? 식사하기 위해서는 젓가락을 두 개를 사용해야하는데 한 철학자가 사용할 경우 옆에 앉은 두 명의 철학자는 젓가락을 두 개를 만들지 못해 식사를 할 수 없게 된다. 따라서 젓가락에 대한 접근을 하는 것에 대한 문제 해결이 필요한 것이다. 이 문제를 프로그래밍을 통해 해결해보자.

![img](https://t1.daumcdn.net/cfile/tistory/24035D5058FAF68F27)

철학자에 대한 정보는 쓰레드와 같다. 젓가락에 대한 접근은 양 옆 철학자에 대해 공통적인 데이터를 접근하는 것과 같다. 임계구역에 접근하는 것과 같아 한 명의 철학자가 젓가락 사용, 즉 임계구역에 접근을 하면 다른 철학자는 그 구역에 접근을 할 수 없다. 그러면 이와 같은 상황을 세마포를 이용해서 상호배타를 만족시키는 상황을 만들 수 있을 것이다. 우선 젓가락과 철학자에 대해 번호를 매긴다. 5개의 임계구역(젓가락)이 만들어져야 하고 각 젓가락 자체가 세마포를 이용해서 접근 제한을 만들기 때문이다. 하나의 젓가락에 대한 세마포는 정수 값의 초기 값으로 1을 가진다. 철학자 한 명이 접근을 하면 다른 철학자가 접근을 하지 못하므로 1명만 접근을 하게 만들기 위해서이다.

철학자라는 쓰레드는 자신의 고유번호를 가지고 왼쪽 젓가락과 오른쪽 젓가락을 가질 수 있다. 먹는 동작과 생각을 하는 동작을 가지고 행동을 하게 된다. 만약 왼쪽 젓가락과 오른쪽 젓가락을 모두 가지게 되면 식사를 하는 동작을 수행하고 그 후 젓가락을 놓고 생각을 하는 동작에 빠지게 된다.

하지만 위와 같은 코드를 실행하면 문제가 발생한다. 바로 모든 철학자가 식사를 하지 못해 굶어 죽는 상황인 starvation인 상태가 발생할 수 있기 때문이다. 우리는 철학자에게 명령을 넣어줄 때 왼쪽 젓가락에 대한 접근을 먼저 주었다. 철학자들은 각자 동작하는 쓰레드이므로 문맥전환이 발생할 수 있다. 그러면 한 명의 철학자가 왼쪽 젓가락에 대한 접근을 하였을 때 문맥전환이 발생했다고 생각해보자. 그 때 자신의 오른쪽에 있던 철학자 쓰레드가 동작하여 왼쪽 젓가락을 잡았다고 생각하자. 그러면 원래 첫 번째로 젓가락을 잡은 철학자 쓰레드의 오른쪽 젓가락을 잡은 것과 같은 상황이다. 이렇게 되면 첫 번째 철학자 쓰레드는 젓가락이 하나 밖에 없어 오른쪽 젓가락을 잡을 수 있는 상황이 될 때까지 기다린다. 왼쪽 젓가락을 잡고 있는 채로 말이다. 그렇게 모든 철학자 쓰레드가 젓가락 하나만 가지고 있는 상태가 되면 프로그램은 돌아가지 않는다. 아무도 식사를 하지 못한 채로 정지되어 있게 된다. 이러한 상황을 starvation이 일어났다고 한다. 1번 쓰레드가 2번 쓰레드의 영향으로 실행을 못하는 상황인데 2번 쓰레드는 1번 쓰레드에 의해 실행을 못하게 되면 두 쓰레드 모두 실행을 하지 못하게 되는 상황이다. 이런 상태를 교착상태라고 한다. 영어로 Deadlock이다. 동기화를 세마포를 통해 설계를 하였는데 교착상태에 빠져 모든 자원이 임계구역에 접근을 하지 못하게 되는 것이다.


# 네트워크





...

#### IPv4

##### NAT(Network Address Translation)

사설 주소와 범용 주소의 매핑을 제공하는 동시에 가상 사설 네트워크를 지원하는 기술 -> 인터넷 네트워크 방화벽의 핵심기술이다. 사설주소의 재사용개념에 근간한 것으로 이러한 기능을 라우터에 구현함으로써 라우터는 각 포트에서 데이터를 받아 NAT매핑 규칙에 따라 IP패킷 발신지 IP주소필드를 고유한 공인 IP주소로 변환하여 전송한다. 

유형 

| NAT유형     | 내용                                                         |
| :---------- | ------------------------------------------------------------ |
| static NAT  | 내부 네트워크 주소와 외부 네트워크 주소간 일대일 매핑하도록 설정하는 방법 |
| Dynamic NAT | 내부 네트워크 주소 그룹(pool)에서 하나의 외부 네트워크 주소를 내부 네트워크 주소와 동적으로 매핑되도록 설정하는 방법 |
| Port NAT    | 여러 개의 내부 네트워크 주소를 하나 또는 몇 개의 외부 네트워크 주소에 포트번호를 다르게 하여 외부 네트워크와 통신하는 방식 |

#### IPv6 주소 체계

공간이 128비트로 들어나면서 주소부족 근본적인 문제를 해결함 



....

### 인터넷 표준



## 데이터 링크계층과 물리적 계층

데이터 링크 계층은 장치간 신호를 전달하는 물리적 계층을 이용하여 네트워크상의 



.... (못함)



### IEEE 802 표준

IEEE 802.3 프로토콜 스택에서는 데이터 링크 계층의 LLC계층에 해당하는 IEEE 802.2 가 있으며 MAC 꼐층과 물리적 계층을 포함하는 IEEE 802.3 , IEEE 802.5, Token Ring , FDDI등이 있다. 

#### IEEE 802.11 표준 





## 5. 전송계층 프로토콜 

> 음성통신도 VoIP 같은 데이터 통신으로 구현되는 것처럼 애플리케이션들이 인터넷에 기반하고 있는 추세이다. 이러한 애플리케이션과 직접적으로 연관있는 프로토콜 계층이 전송계층이면 적절한 프로토콜을 선택해야만 효과적인 네트워크를 사용할 수 있다.

클라이언트와 서버 사이에 많은 홉을 거쳐 데이터패킷이 전달되는데 , 유무선 공유기나 라우터와 같이 종단간 연결시 중간에 위치하는 노드들은 전송계층 프로토콜의 동작에 관여하지 않는다. (TCP, UDP, SCTP는 대표적으로 사용되는 전송계층 프로토콜이다.)

#### 전송 프로토콜 개념

전송계층 프로토콜은 종단호스트(End point host)간 애플리케이션 데이터를 전송해주는 역할을 한다. 서버측에서 실행되는 서버 애플리케이션은 클라이언트측에서 오는 요청을 받아서 처리한 후 그에대한 응답을 클라이언트로 보내준다. 

클라이언트-서버 구조로 동작하며 클라이언트 애플리케이션과 서버 애플리케이션을 이어주는 최하위 프로토콜이 **전송계층 프로토콜** 이다. 

전통적으로 많이 사용되어온 전송계층 프로토콜은 TCP와 UDP이며 TCP와 UDP장점을 조합한 SCTP가 새로 등장했다. 



**UDP** 는 보통 비연결서비스 라고 하는데 연결없이 서비스가 이루어 진다는 것이 아니라 연결을 위한 사전 설정 과정이 생략되고 바로 데이터를 주고 받는 것이 가능하다는 것을 의미한다. (**비신뢰성 프로토콜**)

**TCP** 는 연결지향 서비스로써 데이터를 주고 받기 전 연결을 위한 사전 설명 과정이 필요하며 데이터 송수신이 완료되면 연결을 종료하여 클라이언트 서버가 서비스를 끝내도록 한다. (**신뢰성 프로토콜**) -> seq / ack를 보내 제대로 수신하였는지 확인한다.

제대로 전송되었는지 확인 하는 Wireshark , tcpdump등을 통해서 디버깅 수행한다.



#### TCP

##### 특징

TCP는 TCP/IP모델에서 응용계층과 네트워크 계층 사이에 위치하며 , 두 응용계층 사이의 프로세스 간 통신을 제공한다. TCP는 스트림 기반 프로토콜로 데이터를 송수신하기 위한 송신 버퍼와 수신버퍼를 가진다. TCP프로토콜의 아래층에 있는 **IP는 스트림 형태가 아닌 패킷 형태**로 데이터를 전송하고, 이를 위하여 TCP는 하나의 전체 데이터를 여러개 **세그먼트** 로 나누어 처리한다. 데이터를 신뢰성 있게 전달 할 수 있도록 흐름제어 , 오류제어, 혼잡제어 기법을 정의하고 있다. 

TCP는 바이트 단위로 번호를 매김 -> 바이트 번호가 매겨지면 세그먼트 하나의 순서번호(Sequence Number)가 부여된다. 



1. **흐름제어**

   데이터 패킷을 전송할 때 수신한도를 넘는 과도한 패킷의 입력으로 패킷 분실이 발생하지 않도록 패킷의 흐름양을 조절하는 것을 흐름제어라 한다. 흐름제어 구현은 송신 측과 수신 측에서 패킷을 저장할 수 있는 송신/수신버퍼를 사용한다. 

2. **오류제어**

   전송도중에 발생한 부호오류를 검출하고, 정확한 정보를 재현하는 기술 오류 제어라고 하며, 훼손된 패킷의 감지 및 폐기, 손실되거나 제거된 패킷을 추적하고 재전송, 중복 수신 패킷을 확인하고 폐기하는 기능을 수행한다.

3. **혼잡제어** 

   단위 시간당 네트워크로 전송되는 패킷의 수를 나타내는 네트워크 부하(Load)가 단위 시간당 네트워크에서 처리할 수 있는 패킷의 수를 나타내는 네트워크 용량을 초과하는 경우에는 혼잡이 발생한다. TCP에서는 이러한 종단간 혼잡을 제어하고 네트워크 대역폭보다 부하가 적게 걸리도록 하기 위하여 혼잡제어를 한다.

   

   ![1](/Users/PARKHASIK/Desktop/screen shot/1.png)

   

   ![2](/Users/PARKHASIK/Desktop/screen shot/2.png)




​	

1. TCP연결 설정

   TCP연결을 설정하는 기본 방법이 three-way handshake procedure 이다. 이 절차는 하나의 TCP종단에서 다른 종단으로 순서번호(seq) 가 100 인 SYN세그먼트를 보냄으로써 시작되며 SYN세그먼트는 TCP헤더의 SYN제어 플래그가 1로 설정 된 것을 의미한다. ACK세그먼트는 ACK제어 플래그가 1로 설정된 것이며, SYN,ACK세그먼트는 SYN제어 플래그와 ACK제어 플래그가 모두 1로 설정 되어 있음을 의미한다. 

   SYN세그먼트를 수신한 TCP B는 이에 대한 응답으로 확인 응답번호 101과함께 TCP B에서도 TCP A로 연결 설정을 요청하는 SYN제어 플래그(SEQ=300)을 설정하여 SYN, ACK 세그먼트를 그림3의 3번과 같이 보낸다. 이를 수신한 TCP A 는 ACK제어 플래그와 ACK=101을 확인하여 연결 요청이 제대로 전달된 것을 알 수 있다. 또한 SYN제어 플래그가 같이 설정되어 있어 TCP B에서 연결 요청이 왔음을 알 수 있어 이에대한 ACK세그먼트를 TCP B에 보냄으로써 세 방향 핸드쉐이크가 완성되어 TCP A TCP B간에 양 방향 연결이 설정되었음을 알 수 있다. 

   ![3](/Users/PARKHASIK/Desktop/screen shot/3.png)


2. TCP연결 종료(연결을 종료할 때는 4 way handshake 수행)

   TCP연결 종료는 다음의 순서로 이루어진다. 연결종료를 원하는 종단 TCP A에서 FIN 세그먼트 (SEQ=100, ACK =300)를 단계2와 같이 TCP B로 보낸다. 여기서는 이전 전송에 대한 확인 응답으로 ACK제어 플래그를 같이 설정하여 보내고 있다. 이를 수신한 TCP B에서는 단계 3과 같이 이에대한 ACK세그먼트(SEQ=300, ACK=101)를 응답으로 보낸다. FIN세그먼트의 SEQ=100에 대한 응답으로 ACK는 1증가한 101이 전송된다. 

   이제 TCP B는 단계 4에서처럼 연결종료를 위하여 FIN세그먼트를 TCP A로 보낸다. 단계2에서와 마찬가지로 이전 데이터 전송에 대한 확인 응답을 위하여 ACK를 같이 보내고 있다. 그러면 TCP A는 단계 5와 같이 이에대한 ACK세그먼트를 보내어 TCP연결을 완전히 종료하게 된다. 

![4](/Users/PARKHASIK/Desktop/screen shot/4.png)

**흐름제어** -> 슬라이딩 윈도우 프로토콜을 사용한다.

**오류제어**-> 전송된 세그먼트가 손실되었거나 훼손된 경우 순서가 어긋나는 경우 , 또흔 중복되는 경우에 이에대한 처리기능을 수행하는 것이다.(검사합, 확인응답, 재전송)

**혼잡제어** -> 네트워크로 유입되는 사용자 트래픽양이 네트워크 용량을 초과하지 않도록 유지시키는 매커니즘과 기술이 느린 시작 알고리즘과 혼잡회피 알고리즘 기반으로 혼잡제어 수행한다.



**3 Way (Three Way) Handshake**



![5](/Users/PARKHASIK/Desktop/screen shot/5.png)



**4 Way (Four Way) Handshake**

![6](/Users/PARKHASIK/Desktop/screen shot/6.png)





네트워크



## 프로토콜

- 컴퓨터가 통신하기 위해 미리 정해놓은 약속 대표적으로 TCP/IP가 있다. 
- 사람들끼리 대화에서도 다른 언어를 쓰는 사람과 의사소통이 원활하지 않음 -> 컴퓨터도 마찬가지로 프로토콜이 서로 같은 것만 통신이 가능하게 한다.



### 단편화와 재결합

송신 측에서 전송할 데이터를 전송에 알맞은 적정크기의 작은 블록으로 자르는 것을 **단편화**라고 한다. 수신 측에서 단편화된 블록을 원래의 데이터로 모으는 것을 **재결합**이라고 한다.

- 단편화를 통해 세분화된 데이터 블록을 프로토콜데이터 단위 PDU라고 한다.
- 데이터를 단편화하여 전송하면 전송시간이 빠르고 통신 중의 오류를 효과적으로 제어 할 수 있다.
- 너무 작은 블록으로 단편화할 경우 재결합시 처리기간이 길어지고 , 실제 데이터 외에 부수적인 데이터가 많아지므로 비효율적이다. 

##### 종류

TCP/IP : 컴퓨터와 컴퓨터 통신회선 등으로 연결하기 위한 통신규약

HTTP : 보통 인터넷을 하는데 사용하는 프로토콜(Port 번호 : 80번)

ARP : 목적지 IP의 물리적 주소를 알아내는 프로토콜 

ICMP : 메세지를 알려주고 에러를 알려주는 프로토콜

SNMP

FTP : 컴퓨터 파일을 주고 받는 프로토콜(Port 번호 : 21)

SMTP : 메일 서버와 메일 서버간의 메일을 송수신하는 프로토콜 (Port 번호 : 25)

DHCP



## HTTP 프로토콜이란?

HyperText Transfer Protocol 의 약자로 인터넷 상에서 데이터를 주고받기위한 서버/클라이언트 모델을 따르는 프로토콜이다. 

응용층 레벨의 프로토콜로 TCP/IP위에서 작동한다. **HTTP** 는 어떤 종류의 데이터든지 전송 할 수 있도록 설계되어 있다. HTML뿐만이 아니라 이미지, 동영상, 비디오, 텍스트 문서 등 종류를 가리지 않는다.



**작동방식**

HTTP는 서버/클라이언트 모델방식을 따르며 클라이언트에서 요청(request)을 보내면 서버는 요청을 처리해 응답(response)를 한다.

**connection less** 클라이언트가 서버로 요청하고 데이터를 받으면 서버에서 바로 연결을 끊어버림 

**state less** 이전상태를 알 수 없다 -> 연결이 되면 통신을 끊어버리기 때문에



장점 : 많은 사용자들이 사용가능  -> 접속유지를 최소한으로 할 수 있기 때문에

단점 : 전 상태를 알 수 없다 -> state less 여서 전 상태를 저장하기 위해 쿠키를 사용한다.

   ![EMB0000ee0c1b82](file://localhost/Users/PARKHASIK/Library/Group%20Containers/UBF8T346G9.Office/msoclip1/01/clip_image002.png)



## big endian , little endian 이란?

100에 1000을 추가하려면 big endian 은 100을 3칸 밀고 1을 추가해야하지만 little endian은 001로 저장되어있어서 자리수를 밀 필요없이 그냥 뒤에서 1만 추가해주면 된다.



## TCP와 UDP



..



### POST방식과 GET방식

**GET**은 주소줄에 값이 ? (? 뒤에 입력할 데이터의 정보를 기록한다.) 뒤에 쌍으로 이어붙어있다.(보안(x)) 반면 **POST** 는 숨겨져서 (body 안에)보내진다. 

GET은 URL에 이어붙이기 때문에 길이제한이 있어(255자) 많은 양의 데이터는 보내기 어렵고 POST는 많은 양을 보내기에도 적합하다.

가장 큰 차이는 GET은 Select 적인 성향을 가지고 있다 GET은 서버에 어떤 데이터를 가져와서 보여준다던가하는 용도이지 서버의 값이나 상태등을 바꾸지 않는다. 게시판의 리스트라든지 글보기 기능같은 것에 이에 해당한다. 반면에 POST는 서버의 값이나 상태를 바꾸기 위해서 사용한다. 글쓰기를 하면 글의 내용이 디비에 저장이 되고 수정을 하면 디비값이 수정된다. 이럴경우 POST방식을 사용한다.



- GET 방식 (url로 값을 넘긴다)

클라이언트로부터의 데이터를 이름값과 같이 결합된 스트링 형태로 전달

`<FORM>` 태그 “METHOD” 속성의 값으로는 “GET ”을 입력

전송 데이터의 양 : 255자 

데이터가 주소 입력란에 표시 되므로 최소한의 보안도 유지 되지 않음

- POST 방식(form으로 값을 넘긴다)

`<FORM>` 태그 “METHOD” 속성의 값으로는 “POST ”을 입력

전송 데이터 양 : 제한없음

데이터베이스에 대한 갱신작업과 같은 서버측에서 정보갱신 작업을 원할 때 사용

POST 방식을 사용하면 GET방식에 비해 상대적으로 처리 속도가 늦어짐

POST 방식 : 클라이언트 측에서 데이터를 인코딩 -> 서버측에서 디코딩



POST 방식이 나온이유

1. GET	방식으로 넘길 수 있는 데이터 양은 한계가 있다. 또한, GET방식에는 예약어(? , & 등)가 있다.
2. 사용자에게 값들을 쉽게 노출 시키지 않으려 할 때 사용할 수 있다. 



**3-way-handshaking**

- 쉽게 이야기 하면, 서로의 통싞을 위한 관문(port)를 확인하고 연결하기 위하여 3번의 요청/응답 후에 연결이 되는 것이다. -> 쉽게 말하면 SYN은 “ 문 열어줘” 라고 소리치는 것이다.
- TCP 3 – way – handshaking 은 TCP/IP 프로토콜을 이용해서 통싞을 하는 응용프로그램이 데이터를 젂 송하기 젂에 먼저 정확한 젂송을 보장하기 위해 상대방 컴퓨터와 사젂에 세션을 수립하는 과정을 의미한다.
- 양쪽 데이터 모두 젂송할 준비가 되었다는 것을 보장하고 , 실제로 데이터 젂달이 시작하기 젂에 한쪽이 다른 쪽이 준비 되었다는 것을 알 수 있도록 한다. ※ TCP의 3-way HandShaking 과정

step 1 : 클라이얶트는 서버에 접속을 요청하는 SYN 패킷을 보낸다. 이때 클라이얶트는 SYN을 보내고 ACK응답을 기다린다. -> 응답 시갂이 길어지면 timeout이 발생해 클라이얶트는 SYN패 킷을 다시 보낸다. (재젂송)

step 2 : 서버는 SYN 요청을 받고 클라이얶트에게 요청을 수락한다는 ACK와 SYN flag가 설정 된 패킷을 발송하고 클라이얶트가 다시 ACK로 응답하기를 기다린다.

step 3 : 클라이얶트는 서버에게 ACK를 보내고 이후부터는 연결이 이루어지고 데이터가 오가게 된다.



**4 – way handshaking**

3-way-handshake가 TCP의 연결을 설정할 때 사용한다면, 4-way -handshake는 연결을 종료하 기 위해 사용하는 젃차이다.

※ TCP의 4-way HandShaking 과정

step 1 : 클라이얶트가 연결을 종료하겠다는 FIN 플래그를 전송한다.

step 2 : 서버는 일단 확인메시지를 보내고 클라이얶트는 서버가 돌리고 있는 프로그램이 끝날 때 까지 기다린다.

step 3 : 서버가 통싞이 끝났으면 연결이 종료되었다고 클라이얶트에게 FIN플래그를 젂송한다.

step4 : 클라이언트는 서버로부터 FIN플래그를 받고 바로 ACK를 보내는 것이 아닌 TIME_WAIT 라는 일정시갂 동안 기다리고 ACK를 보낸다. ( 서버에서 FIN을 젂송하기 젂에 젂송 한 패킷이 Routing 지연이나 패킷 유실로 인한 재젂송 등으로 인해 FIN 패킷 보다 늦게 도착하 는 상황이 발생한다면??)



## 흐름제어





## 혼잡제어





## 로드밸런싱

하나의 인터넷 서비스가 발생하는 트래픽이 많을 때 여러대의 서버가 분산처리 하여 서버의 로드율 증가, 부하량, 속도처하등을 고려하여 적절히 분산처리 하여 해결해주는 서비스이다.(부하 분산을 위해 가상 IP를 통해 여러 서버에 접속하도록 분배하는 기능)



인터넷 트래픽은 매년 100% 이상 증가하고 있지만 서버 성능은 트래픽 증가분을 따라가지 못하 고 있다. 이 문제는 크게 2가지 방법으로 해결할 수 있다.

하나는 Scale_up 즉, 수직방향으로 CPU,메모리, 디스크 기능을 업그레이드 하는 방법 -> 기능을 향상시키면 그만큼 비용도 올라간다.

다른하나는 Scale_out 즉, 수직방향으로 노드를 추가해서 성능을 업그레이드 하는 방법 (로드 밸런싱) 저렴한 노드를 여러개 묶어서 성능을 업그레이드 하는데 scale_up방식에 비해서 비용을 크게 줄일 수 있으며 유연한 구성이 가능하다. cluster를 구성하는 하나의 노드에 문제가 생기더라도 서비스가 중단되지 않기 때문에 가용성을 확보하기 쉽다는 장점이 있다. 일반적으로 로드 벨런싱은 웹 사이트나 FTP, DNS 등 클라이언트 요청이 많은 서비스에 주로 사용한다.

**2가지 종류**



## 도메인



## 브라우저에 URL치면 어떤일 발생?






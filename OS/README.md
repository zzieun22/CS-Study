

### [운영체제 관련 공부](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4)

[운영체제](http://copycode.tistory.com/71?category=740133)

## 프로세스와 스레드 차이

### **프로세스**

프로세스는 진행중인 프로그램!
디스크로부터 메모리에 적재되어 CPU의 할당을 받을 수 있는것을 말한다. 운영체제로부터 주소 공간, 파일, 메모리 등을 할당받으며 이것들을 총칭하여 프로세스라고 한다. 구체적으로 살펴보면 프로세스는 함수의 매개변수, 복귀 주소와 로컬 변수와 같은 임시 자료를 갖는 프로세스 스택과 전역 변수들을 수록하는 데이터 섹션을 포함한다. 또한 프로세스는 프로세스 실행 중에 동적으로 할당되는 메모리인 힙을 포함한다.

#### 프로세스 제어 블록(Process Control Block, PCB)

PCB 는 특정 프로세스에 대한 중요한 정보를 저장 하고 있는 운영체제의 자료구조이다. 운영체제는 프로세스를 관리하기 위해 프로세스의 생성과 동시에 고유한 PCB 를 생성 한다. 프로세스는 CPU 를 할당받아 작업을 처리하다가도 프로세스 전환이 발생하면 진행하던 작업을 저장하고 CPU 를 반환해야 하는데, 이때 작업의 진행 상황을 모두 PCB 에 저장하게 된다. 그리고 다시 CPU 를 할당받게 되면 PCB 에 저장되어있던 내용을 불러와 이전에 종료됐던 시점부터 다시 작업을 수행한다.

PCB 에 저장되는 정보

* 프로세스 식별자(Process ID, PID) : 프로세스 식별번호
* 프로세스 상태 : new, ready, running, waiting, terminated 등의 상태를 저장
* 프로그램 카운터 : 프로세스가 다음에 실행한 명령어의 주소
* CPU 레지스터
* CPU 스케쥴링 정보 : 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등
* 메모리 관리 정보 : 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함
* 입출력 상태 정보 : 프로세스에 할당된 입출력장치들과 열린 파일 목록
* 어카운팅 정보 : 사용된 CPU 시간, 시간제한, 계정번호 등  



## 스레드(Thread)

스레드는 프로세스의 실행 단위라고 할 수 있다. 한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 주소 공간이나 자원을 공유할 수 있다. 스레드는 스레드 ID, 프로그램 카운터, 레지스터 집합, 그리고 스택으로 구성된다. 같은 프로세스에 속한 다른 스레드와 코드, 데이터 섹션, 그리고 열린 파일이나 신호와 같은 운영체제 자원들을 공유한다. 하나의 프로세스를 다수의 실행 단위로 구분하여 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상시키는 것을 멀티스레딩이라고 한다. 이 경우 각각의 스레드는 독립적인 작업을 수행해야 하기 때문에 각자의 스택과 PC 레지스터 값을 갖고 있다.

**스택을 스레드마다 독립적으로 할당하는 이유**

스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간이므로 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고 이는 독립적인 실행 흐름이 추가되는 것이다. 따라서 스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택을 할당한다.

**PC Register 를 스레드마다 독립적으로 할당하는 이유**

PC 값은 스레드가 명령어의 어디까지 수행하였는지를 나타나게 된다. 스레드는 CPU 를 할당받았다가 스케줄러에 의해 다시 선점당한다. 그렇기 때문에 명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행했는지 기억할 필요가 있다. 따라서 PC 레지스터를 독립적으로 할당한다.

---
## 멀티 스레드

### 멀티 스레딩의 장점

프로세스를 이용하여 동시에 처리하던 일을 스레드로 구현할 경우 메모리 공간과 시스템 자원 소모가 줄어들게 된다. 스레드 간의 통신이 필요한 경우에도 별도의 자원을 이용하는 것이 아니라 전역 변수의 공간 또는 동적으로 할당된 공간인 Heap 영역을 이용하여 데이터를 주고받을 수 있다. 그렇기 때문에 프로세스 간 통신 방법에 비해 스레드 간의 통신 방법이 훨씬 간단하다. 심지어 스레드의 context switch 는 프로세스 context switch 와는 달리 캐시 메모리를 비울 필요가 없기 때문에 더 빠르다. 따라서 시스템의 throughtput 이 향상되고 자원 소모가 줄어들며 자연스럽게 프로그램의 응답 시간이 단축된다. 이러한 장점 때문에 여러 프로세스로 할 수 있는 작업들을 하나의 프로세스에서 스레드로 나눠 수행하는 것이다.


### 멀티 스레딩의 문제점

멀티 프로세스 기반으로 프로그래밍할 때는 프로세스 간 공유하는 자원이 없기 때문에 동일한 자원에 동시에 접근하는 일이 없었지만 멀티 스레딩을 기반으로 프로그래밍할 때는 이 부분을 신경써줘야 한다. 서로 다른 스레드가 데이터와 힙 영역을 공유하기 때문에 어떤 스레드가 다른 스레드에서 사용중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정할 수 있다.

그렇기 때문에 멀티스레딩 환경에서는 동기화 작업이 필요하다. 동기화를 통해 작업 처리 순서를 컨트롤 하고 공유 자원에 대한 접근을 컨트롤 하는 것이다. 하지만 이로 인해 병목현상이 발생하여 성능이 저하될 가능성이 높다. 그러므로 과도한 락으로 인한 병목현상을 줄여야 한다.


###  멀티 스레드 vs 멀티 프로세스

멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥 전환이 빠르다는 장점이 있지만, 오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다는 점과 동기화 문제를 안고 있다. 반면 멀티 프로세스 방식은 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않고 정상적으로 수행된다는 장점이 있지만, 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지한다는 단점이 존재한다. 이 두 가지는 동시에 여러 작업을 수행한다는 점에서 같지만 적용해야 하는 시스템에 따라 적합/부적합이 구분된다. 따라서 대상 시스템의 특징에 따라 적합한 동작 방식을 선택하고 적용해야 한다.

---
## 스케줄러

프로세스를 스케줄링하기 위한 Queue 에는 세 가지 종류가 존재한다.

* Job Queue : 현재 시스템 내에 있는 모든 프로세스의 집합
* Ready Queue : 현재 메모리 내에 있으면서 CPU 를 잡아서 실행되기를 기다리는 프로세스의 집합
* Device Queue : Device I/O 작업을 대기하고 있는 프로세스의 집합

각각의 Queue 에 프로세스들을 넣고 빼주는 스케줄러에도 크게 세 가지 종류가 존재한다.

### 장기스케줄러(Long-term scheduler or job scheduler)

메모리는 한정되어 있는데 많은 프로세스들이 한꺼번에 메모리에 올라올 경우, 대용량 메모리(일반적으로 디스크)에 임시로 저장된다. 이 pool 에 저장되어 있는 프로세스 중 어떤 프로세스에 메모리를 할당하여 ready queue 로 보낼지 결정하는 역할을 한다.

* 메모리와 디스크 사이의 스케줄링을 담당.
* 프로세스에 memory(및 각종 리소스)를 할당(admit)
* degree of Multiprogramming 제어
 메모리에 여러 프로그램이 올라가는 것) 몇 개의 프로그램이 올라갈 것인지를 제어
* 프로세스의 상태
new -> ready(in memory)

cf) 메모리에 프로그램이 너무 많이 올라가도, 너무 적게 올라가도 성능이 좋지 않은 것이다. 참고로 time sharing system 에서는 장기 스케줄러가 없다. 그냥 곧바로 메모리에 올라가 ready 상태가 된다.


### 단기스케줄러(Short-term scheduler or CPU scheduler)

* CPU 와 메모리 사이의 스케줄링을 담당.
* Ready Queue 에 존재하는 프로세스 중 어떤 프로세스를 running 시킬지 결정.
* 프로세스에 CPU 를 할당(scheduler dispatch)
* 프로세스의 상태
ready -> running -> waiting -> ready


### 중기스케줄러(Medium-term scheduler or Swapper)

* 여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아냄 (swapping)
* 프로세스에게서 memory 를 deallocate
* degree of Multiprogramming 제어
* 현 시스템에서 메모리에 너무 많은 프로그램이 동시에 올라가는 것을 조절하는 스케줄러.
* 프로세스의 상태
ready -> suspended

**Process state - suspended**

Suspended(stopped) : 외부적인 이유로 프로세스의 수행이 정지된 상태로 메모리에서 내려간 상태를 의미한다. 프로세스 전부 디스크로 swap out 된다. blocked 상태는 다른 I/O 작업을 기다리는 상태이기 때문에 스스로 ready state 로 돌아갈 수 있지만 이 상태는 외부적인 이유로 suspending 되었기 때문에 스스로 돌아갈 수 없다.

---
CPU 스케줄러  
동기와 비동기의 차이  
프로세스 동기화  
메모리 관리 전략   
가상 메모리   
캐시의 지역성  등  

---
## 운영체제

### 프로세스

**Multiprogramming

다중프로세스를 활용하는 다중 프로그래밍 시스템이다. 메인 메모리에 여러 가지 프로세스를 올려 작업을 처리할 수 있게 해주는 시스템이다. 프로세스의 종류 중에는 I/O와 같이 Device를 주로 사용하는 프로세스가 있을 수 있고 CPU를 주로 사용하는 프로세스가 있을 수 있다. 그런데 메인 메모리로 올라오는 프로세스의 종료가 한 쪽으로 치우친다면 프로세스를 처리하는데 사용되는 시간이 매우 오래 걸리게 될 것이다. 그래서 Job scheduler에서는 두 종류의 프로세스를 적절히 조화를 시켜 메인 메모리에 올린다.   

다중 프로그래밍 시스템에서 가장 중요한 작업은 메모리에 있는 안 쓰는 프로세스는 하드디스크로 보내고 다시 사용하는 프로그램은 적절하게 메인 메모리로 올리는 작업을 진행하여야 한다. 이런 작동을 Swapping이라고 한다. 이런 작동을 하기 위해서는 적절한 **문맥전환(Context switching)**이 필수적이다. 그런 역할을 하는 장치들은 Scheduler와 Dispatcher가 있다. Scheduler는 위에 설명하였듯이 선택을 하는 존재이다. 어떤 프로세스가 적절한지에 대한 선택을 **Scheduler**가 진행하며 그에 대한 실행, 할당은 **Dispatcher**가 진행하게 된다.

### 스레드및 프로세스 동기화

스레드는 프로그램 내부에 흐르는 맥, 흐름 이라고 한다. 를 들어 자바나 C로 프로그램을 작성할 때 메인 함수를 통해 각종 표현식이 돌아 프로그램이 끝이 나는 것을 “맥이 흐른다.”라고 한다 .

하지만 한 프로그램에 2개이상의 맥이 흐를 수 있는데 이것을 **다중스레드** 라고 한다. 시간간격이 매우 짧아 동시에 맥이 흐르는 것처럼 보인다.



대부분프로그램은 -> 다중스레드

한 프로세스 내의 다중 스레드는 프로세스의 메모리공간공유, 자원공유도한다. 

모든 프로그램은 메인스레드라는 기본적인 스레드를 가지고 있다. (main 함수)

프로세스 관리에 중요한 역할은 **스케줄링** 과 **동기화**이다. 



**CPU 스케줄링 알고리즘**

우선 **FCFS(First-Come, First-Served)**이다.

말 그대로 먼저 들어온 프로세스를 먼저 실행하는 알고리즘이다. 어떻게 말해서는 가장 간단하고 공정한 알고리즘이 될 수 있지만 평균 대기시간을 비교하는 척도로 하면 좋은 알고리즘이라고 할 수 없다. FCFS는 비선점 스케줄링으로 프로세스가 끝날 때까지 다른 프로세스들이 기다려야한다. FCFS를 이용하게 되면 Convoy effort(호위 효과)를 발생시킬 수 있는데 이 효과는 CPU를 이용하는 시간이 긴 프로세스를 다른 프로세스들이 오래 기다리고 있는 효과로 마치 긴 프로세스를 호위하며 둘러싸고 있다고 해서 이런 이름이 붙여졌다.

다음은 **Shortest-Job-First**이다.

이 알고리즘도 이름에서 유추하듯이 가장 짧은 CPU 할당 시간을 가진 프로세스를 먼저 처리하는 방식이다. 평균 대기시간을 척도로 하면 가장 합리적인 방법이라고 할 수 있다. 하지만 실제로 CPU 할당 시간을 정확하게 알 수 없으므로 예측을 통해 진행해야한다. 이 알고리즘은 선점 방식일수도 있고 비선점 방식일수도 있다.

프로세스에 정수 값인 우선순위를 주어 CPU를 할당할 수 있는 알고리즘도 있다. 우선순위 스케줄링이라고 불리는데 내부적 외부적으로 다양한 조건들을 활용해 프로세스에 우선순위를 부여한다. 숫자가 작을수록 우선순위가 높아진다. 이 알고리즘도 선점 방식일수도 있고 비선점 방식일수도 있다. 하지만 이 알고리즘은 기아라는 프로세스를 발생시킬 수 있다. 이 프로세스는 우선순위가 낮은 프로세스로 계속해서 이 프로세스보다 우선순위가 높은 프로세스가 들어오게 되면 절대로 처리를 할 수 없게 된다. 이런 문제를 해결하기 위해 aging이라는 기법을 사용하는데 우선순위가 낮은 프로세스가 계속 처리를 못하고 있으면 우선순위를 높여주어 처리를 할 수 있게 해준다.

다음은 **Round-Robin**이라는 알고리즘이다. 시분할 시스템에서 사용하는 알고리즘으로 CPU를 할당하는 방법으로 Time quantum을 사용한다. Time quantum은 시간 양자라고 하는데 일정시간을 선정하여 CPU 할당을 모든 프로세스에게 동일하게 분담하는 것이다. 이러한 작업은 모든 프로세스가 동시에 할당되고 있는 것처럼 보이게 된다. 여기서 성능은 시간 양자를 얼마의 사이즈로 잡느냐에 따라 달라진다. 이 알고리즘은 시간 양자에 따라 다른 프로세스로 바꾸어주기 때문에 선점 방식이다.

다음으로는 위와 같은 알고리즘은 아니지만 프로세스의 종류에 따라 다른 level을 두어 스케줄링을 하는 **Multilevel Queue Scheduling**이다. 시스템 프로세스, Interative process, Interactive editing process 등등으로 프로세스 그룹을 나누게 된다. Queue를 여러 개 두어 각 Queue마다 처리하는 프로세스를 다르게 처리한다. Queue에도 우선순위가 존재하며 CPU 시간을 차등으로 배분하게 된다. 각 Queue들은 독립적인 스케줄링 알고리즘을 가지게 된다.

Multilevel Feedback Queue Scheduling도 있는데 Multilevel Queue Scheduling과 같이 복수 개의 Queue를 가지지만 다른 Queue로 점진적으로 이동한다는 점이 다르다. 하나의 입구로 진입하여 너무 많은 CPU time을 사용 시 다른 Queue로 이동하게 되고 기아 상태가 될려고 하면 다시 우선순위가 높은 Queue로 이동하게 된다.

 

### 프로세스 관리 -스케줄링-

CPU스케줄링은 크게 두가지 특징으로 나눌 수 있다. 

**선점하는 방식** & **비선점하는 방식** 

선점하는 방식은 하나의 프로세스가 CPU를 할당받아 작업을 수행하고 있는 도중에 다른 프로세스가 새치기를 할 수 있는 방식이다. 

하지만 비선점하는 방식은 하나의 프로세스가 CPU할당이 끝나야 다른 프로세스가 CPU를 할당 받을 수 있는 형식이다. 선점과 비선점에의해 컴퓨터 성능에 영향을 끼친다.



### 임계구역 문제 및 세마포어

동시에 은행계좌에 업데이트를 하면 문제가 발생할 수 있다. 우리는 한 번에 한 스레드만 업데이트하는 프로세스 동기화가 필요하다. 이러한 문제를 임계구역문제 라고 한다.

EX> 은행계좌문제에서 부모님은 은행계좌에 입금 학생은 출금하는 형식을 가지고있다. 부모님과 학생은 스레드를 의미한다. 은행계좌는 공통적으로 사용하는데이터가 된다. 

**임계구역**을 해결하기위해서 3가지가 만족되어야 한다.

1. **상호배타** -> 한순간에 업데이트는 한스레드만 가능하다
2. **진행**-> 누가 먼저 들어갈지 결정을 유한시간내에 해야한다.
3. **유한대기** -> 스레드가 유한시간내에 접근해야한다. 무한한대기의 경우가 발생해서는 안된다. 





## Semaphore

프로세스/ 스레드 동기화는 여러개의 프로세스/스레드가 공통으로 데이터에 접근하려고 할 때 발생하는 문제를 해결하는 방법이다. 

**세마포어** -> 운영체제 동기화를 위한 도구 중 하나이다.

스레드가 동작하는 공간에는 공통 데이터를 수정할 수 있는 임계구역이 존재한다.  스레드가 동작하면서 임계구역에 들어가게 되면 데이터를 수정할 수 있다. 코드동작도중 acquire()라는 명령어가 실행되면 임계구역에 들어가라는 명령어이므로 스레드가 임계구역에 들어가기된다. release()되면 임계구역 나옴 



문제 -> 스레드가 자신의 임계구역에 들어가서 공통으로 사용하는 데이터를 수정하고 있는 상황에서 **문맥전환** 에 의해 다른 스레드가 자신의 임계구역에 들어가서 공통으로 사용하는 데이터를 수정하려는 시도할 때 **임계구역 문제**가 발생할 수 있다.

발생하지 않게 하는 방법이 **상호배타** 이다. 상호배타를 만족시킬 수 있는 방법은 **세마포** 라는 도구를 통해서 만들어진다. 

*세마포어* 는 정수값을 가지는데 처음에 나타나는 정수는 임계구역에 들어갈 수 있는 스레드 수를 나타낸다. acquire() 명령어를 실행해서 임계구역에 들어가게 되었을 때 문맥 전환에 의해 다른 스레드가 acquire() 명령어를 실행했다고 하더라도 임계구역에 들어갈 수 없게 막는 공간이 세마포어이다.



**동작원리**

세마포 (스레드를 보관하는 Queue를 가진다) 는 정소값을 가짐 ex> (1) -> 임계구역에 접근 가능한 스레드는 하나! 이다.

if 임계구역에 스레드가 존재하지 않을경우 acquire()명령을 실행 할 수 있다. 

-> 세마포는 acquire()명령을 받았으니 1 감소시킴 (정수값이 0보다 작아지면 세마포의 Queue에 스레드를 block 시킨다.)

-> 이 상황은 0이므로 block하지말고 바로 임계구역으로 이동해 명령을 수행한다. 

But 컴퓨터의 CPU할당은 문맥전환에 의해 다른 스레드로 갈수 있음 

if 다른 스레드가 문맥전환에의해 코드가 실행되었다면? 그런데 이 다른 스레드가 또 acquire()명령을 실행한다면? 

-> 두번째 스레드도 임계구역에 들어가고 싶어함 

But 이미 하나의 쓰레드가 임계구역에 존재하고 있으므로 들어가면 안된다. 

이를 제어하는것이 **세마포어**

acquire() 명령이 또 실행되었으니 세마포어 정수값은 -1이 된다. 그럼 0보다 작아져 두번째 스레드는 세마포어의 Queue에 block를 당해 임계구역에 접근하지 못하는 상황이 된다. 

-> 들어가려면 먼저 임계구역에 들어간 스레드가 release()라는 명령어를 통해 +1 시켜주면 대기하고있던 스레드가 wakeup을 통해 세마포어를 탈출할 수 있게 된다. 



이런 방식을 통해 임계구역을 접근할 수 없게 하는 **상호배타** 적용이 가능해진다.



> 세마포는 프로세스 실행순서를 원하는대로 제어하는 역할도 할 수 있다. 



### 프로세스 관리 (생산자 소비자 문제)

생산자-소비자 문제는 생산자가 데이터를 생성하면 소비자는 그것을 소비하는 형태에서 발생하는 문제를 말한다.

일반적으로 생산속도와 소비속도의 차이가 존재한다. 생산속도가 소비하는 속도보다 빨라서 데이터는 바로 소비되지 못한다. 이를 보완하기 위해 생산된 데이터를 보관하는 *버퍼*라는 공간이 존재한다. 버퍼의 크기는 유한하다.(Bounded Buffer) 버퍼가 가득차면 더이상 넣을 수 없고 소비자는 버퍼가 비면 뺄 수 없다.

우선 버퍼에 대한 클래스를 만들어 버퍼를 정수 값으로 지정을 하였다. size는 버퍼의 크기를 나타내고 count는 버퍼에 들어와 있는 데이터의 개수라고 할 수 있다. 생산된 데이터가 버퍼로 들어오면 count를 1증가시키고 소비자가 빼어 가면 1감소시킨다. in은 데이터를 넣는 위치를 out은 빼내는 위치를 가리킨다. in 값은 데이터가 들어올 때마다 1씩 증가하고 out 값은 데이터가 나갈 때마다 1씩 증가한다. 만약 in의 값이 size까지 가게 되면 다시 처음 0의 값으로 돌아가서 데이터를 넣기 시작한다. 버퍼가 가득 차여져 있으면 out이 실행되기 전까지 무한루프를 돌면서 데이터를 넣지 못하고 기다리고 있는 상태가 된다. 반대로 버퍼가 비어져 있으면 out은 실행되지 못하고 무한루프를 돌게 되고 in으로 데이터가 들어오기를 기다리게 된다.

![img](https://t1.daumcdn.net/cfile/tistory/2341DA4158F87CED1E)

생산자와 소비자는 서로 다른 동작을 하는 쓰레드로 제작을 하면 된다. 생산자의 쓰레드의 경우는 N번 데이터를 생산하여 버퍼에 넣어주는 작업을 소비자의 쓰레드는 N번 데이터를 버퍼에서 가져와 소비하는 작업을 만들어 준다. 메인함수에서는 100크기의 버퍼를 만들고 N을 만 번으로 지정한다.

![img](https://t1.daumcdn.net/cfile/tistory/2401654158F87CED1A)

위의 코드를 실행하게 되면 당연히 만 번 데이터가 들어가고 만 번 데이터가 나와 결과적으로 버퍼의 count는 0이 되어야 하는데 실행을 해보면 그렇게 되지 않는 경우가 발생하는 것을 알 수 있다. 또한 실행이 불가한 경우도 발생한다. 이러한 문제가 발생하는 이유가 바로 쓰레드 동기화가 되지 않았기 때문이다. 공통변수인 count, buf에 대한 동시 업데이트가 발생하여 값의 변화에 문제가 생긴다. 공통변수 업데이트 구간인 임계구역에 대한 동시 진입이 가능하므로 데이터의 변화가 따로 발생할 수 있으므로 문제가 발생한다. 다시 말해 생산자가 count를 올리고 있는 도중에 문맥전환에 의해 소비자가 돌게 되어 count를 낮추는 작업을 하게 되면 count의 값에 오류가 발생하는 것이다.

이를 해결하기 위해서는 임계구역에 대한 동시 접근을 방지하는 상호배타의 기능이 추가되어야한다. 우리는 앞장을 통해 상호배타를 적용시킬 수 있는 방법을 알고 있다. 바로 세마포를 이용하여 상호배타를 적용시켜 주는 것이다. 세마포의 정수 값을 1로 두어 생산자나 소비자 중 하나만이 임계구역에 들어갈 수 있도록 해주어야 한다. 이렇게 세마포를 만들게 되면 생산자가 데이터를 생산하여 버퍼에 넣어주는 작업을 수행하게 되면 소비자는 데이터를 빼내는 작업을 할 수 없게 된다. 공통된 값인 count와 buf에 관련된 업데이트가 동시에 되지 않으므로 오류가 발생하지 않는다.

자바 코드에서 수정을 하는 부분은 insert와 remove 공간에서 버퍼의 데이터를 업데이트 해주는 부분을 감싸는 acquire()명령어와 release()명령어를 입력해주면 된다. 물론 세마포에 대한 정의를 따로 해주어야 한다. 우리는 이렇게 세마포를 사용하여 프로세스/쓰레드 동기화를 시켜주어 오류를 수정해 줄 수 있다.

![img](https://t1.daumcdn.net/cfile/tistory/21118D4358F87DD116)

하지만 위의 과정은 오류에 대한 수정은 하였지만 기다려야하는 시간이 길어질 수 있다. 앞의 키워드에서 주어졌듯이 생산자는 버퍼가 가득 차 있으면 기다려야하고 소비자는 버퍼가 비어 있으면 기다려야한다. 코드를 보면 무한루프를 돌면서 계속 CPU가 할당되어 잡혀있는데 이런 시간은 매우 좋지 않다. 이런 기다림을 Busy-wait이라고 한다. CPU가 아무 일도 하지 않게 되면 성능이 매우 낭비가 된다. 이를 해결하는 것도 세마포를 이용해서 할 수 있다. 세마포의 장점 중 하나는 프로세스나 쓰레드의 실행 순서를 사용자가 원하는 순서에 따라 작업을 수행시킬 수 있게 하는 것이다. 만약 버퍼가 가득 차여 있으면 세마포의 공간에 생산자를 가두어 CPU가 할당 받지 못하도록 한다. 이렇게 되면 CPU는 무조건 소비자에게 CPU를 할당할 수밖에 없어 버퍼의 빈 공간을 만들어 주게 된다. 반대로 버퍼가 비어있으면 CPU할당을 생산자에게 주어 버퍼를 채우게 한다.

이러한 세마포를 재작해보자. 위와 같은 동작을 하려면 세마포를 두 개를 재작해야한다. 생산자와 버퍼와의 관계를 제어할 수 있는 세마포(empty)와 소비자와 버퍼의 관계를 제어하는 세마포(full)가 필요하다. 생산자와 버퍼를 제어하는 세마포는 정수 값의 초기 값을 size 값으로 가지게 된다. 데이터가 계속 버퍼에 들어가는데 버퍼가 size만큼 들어가게 되면 생산자는 block이 되어야한다. 반대로 소비자의 세마포는 비어 있을 때 block되어야 하므로 정수 값의 초기 값으로 0을 가진다. 버퍼에 데이터가 들어오면 정수의 값을 증가시키고 데이터가 없는 빈 버퍼가 되었을 때 acquire()명령으로 데이터를 빼내오려고 한다면 정수 값이 0보다 작은 값을 가지게 되므로 소비자 쓰레드를 block 시킨다. 두 개의 세마포는 release를 명령을 보내게 되면 상대방의 세마포를 풀어주어 동작을 할 수 있게 한다. 이렇게 제어를 하게 되면 CPU가 무한 루프를 돌고 있는 작업을 하는 것을 막을 수 있다.

 ![img](https://t1.daumcdn.net/cfile/tistory/2701CC4158F87CEE2C)   

[출처](http://copycode.tistory.com/67?category=740133)

### 읽기쓰기 문제 (식사하는 철학자)

읽기 쓰기 문제는 공통 데이터베이스에 접근하는 문제를 다룬다. 서버에 데이터베이스가 존재하는데 다른 로컬 컴퓨터들이 데이터에 접근을 할 수 있다. 접근하는 사용자 중에는 Reader와 Writer가 존재한다. Reader는 데이터를 읽기만 하는 사용자이고 Writer는 데이터를 읽고 수정할 수 있는 사용자를 의미한다. 데이터베이스를 사용자들이 모두 공통 사용하므로 임계구역이라고 생각할 수 있다.

우리는 앞의 임계구역 문제를 해결하기 위해 동기화를 사용하였는데 상호배타를 만족시키기 만들어 한 번에 한 개의 프로세스만 접근이 가능하게 만들었다. 임계구역에 데이터를 접근하는 사용자에 접근 권한을 두어 동시에 접근을 할 수 없게 만들었다. 하지만 위의 읽기 쓰기 예시를 한 번 살펴보면 이런 점이 매우 비효율적이라는 것을 알 수 있다.

만약 사용자 Reader1이 데이터베이스에 접근을 했는데 다른 Reader2가 데이터베이스에 접근을 한다고 문제가 발생할까? Reader는 데이터를 읽기만 하는 사용자를 의미한다. 따라서 데이터베이스에 접근을 하더라도 데이터의 변형을 만들지 않아 문제를 발생시키지 않는다. 효율성의 제고를 통해 Reader이 동시에 접근하려고 하면 접근 권한을 주어도 된다. 그러면 Writer의 경우는 어떨까? Writer는 데이터를 읽기도 하지만 쓰기도 한다. 즉 데이터의 변형, 업데이트가 일어난다. 따라서 Writer 두 사용자가 동시에 접근하면 문제가 발생할 수 있다. 그러면 Reader가 들어왔는데 Writer가 접근을 하고 싶어 하면 어떻게 될까? Reader가 읽고 있는 데이터가 Writer에 의해 변형, 업데이트 되므로 문제가 발생할 수 있다. Reader는 제대로 된 데이터를 읽을 수 없기 때문이다.

![img](https://t1.daumcdn.net/cfile/tistory/273B225058FAF69035)

그러면 어떻게 설계를 해야 할까?

∙Reader가 데이터베이스(임계구역) 들어갈 경우, 다른 Reader는 접근할 수 있으나 Writer는 접근할 수 없다.

∙Writer가 데이터베이스(임계구역) 들어갈 경우, Reader와 Writer 모두 접근할 수 없다.

 

위의 문제를 해결하기 위해서는 우선순위를 이용하여 해결할 수 있다. Reader에게 먼저 우선권을 주어 Reader가 접근을 하면 Writer는 반드시 다음으로 실행이 되어야한다.

 

식사하는 철학자 문제는 5명의 철학자가 식사를 하고 있는 상황을 가정한 문제이다. 철학자들이 원형의 테이블에 앉아 있는데 철학자들 사이에는 젓가락이 놓여있다. 하지만 젓가락이 한 쌍이 놓여 있는 게 아니라 하나가 놓여있는 상황이다. 철학자는 생각을 하면서 산다. 그러다가 배가 고프면 자신의 양 옆에 있는 젓가락을 사용해서 식사를 하고 또 다시 생각을 한다. 이러한 상황을 가정한 문제가 식사하는 철학자 문제이다. 여기서 어떤 문제가 발생하겠는가? 만약 서로 양 옆에 앉아 있는 철학자 같이 배가 고플 경우 어떻게 되겠는가? 식사하기 위해서는 젓가락을 두 개를 사용해야하는데 한 철학자가 사용할 경우 옆에 앉은 두 명의 철학자는 젓가락을 두 개를 만들지 못해 식사를 할 수 없게 된다. 따라서 젓가락에 대한 접근을 하는 것에 대한 문제 해결이 필요한 것이다. 이 문제를 프로그래밍을 통해 해결해보자.

![img](https://t1.daumcdn.net/cfile/tistory/24035D5058FAF68F27)

철학자에 대한 정보는 쓰레드와 같다. 젓가락에 대한 접근은 양 옆 철학자에 대해 공통적인 데이터를 접근하는 것과 같다. 임계구역에 접근하는 것과 같아 한 명의 철학자가 젓가락 사용, 즉 임계구역에 접근을 하면 다른 철학자는 그 구역에 접근을 할 수 없다. 그러면 이와 같은 상황을 세마포를 이용해서 상호배타를 만족시키는 상황을 만들 수 있을 것이다. 우선 젓가락과 철학자에 대해 번호를 매긴다. 5개의 임계구역(젓가락)이 만들어져야 하고 각 젓가락 자체가 세마포를 이용해서 접근 제한을 만들기 때문이다. 하나의 젓가락에 대한 세마포는 정수 값의 초기 값으로 1을 가진다. 철학자 한 명이 접근을 하면 다른 철학자가 접근을 하지 못하므로 1명만 접근을 하게 만들기 위해서이다.

철학자라는 쓰레드는 자신의 고유번호를 가지고 왼쪽 젓가락과 오른쪽 젓가락을 가질 수 있다. 먹는 동작과 생각을 하는 동작을 가지고 행동을 하게 된다. 만약 왼쪽 젓가락과 오른쪽 젓가락을 모두 가지게 되면 식사를 하는 동작을 수행하고 그 후 젓가락을 놓고 생각을 하는 동작에 빠지게 된다.

하지만 위와 같은 코드를 실행하면 문제가 발생한다. 바로 모든 철학자가 식사를 하지 못해 굶어 죽는 상황인 starvation인 상태가 발생할 수 있기 때문이다. 우리는 철학자에게 명령을 넣어줄 때 왼쪽 젓가락에 대한 접근을 먼저 주었다. 철학자들은 각자 동작하는 쓰레드이므로 문맥전환이 발생할 수 있다. 그러면 한 명의 철학자가 왼쪽 젓가락에 대한 접근을 하였을 때 문맥전환이 발생했다고 생각해보자. 그 때 자신의 오른쪽에 있던 철학자 쓰레드가 동작하여 왼쪽 젓가락을 잡았다고 생각하자. 그러면 원래 첫 번째로 젓가락을 잡은 철학자 쓰레드의 오른쪽 젓가락을 잡은 것과 같은 상황이다. 이렇게 되면 첫 번째 철학자 쓰레드는 젓가락이 하나 밖에 없어 오른쪽 젓가락을 잡을 수 있는 상황이 될 때까지 기다린다. 왼쪽 젓가락을 잡고 있는 채로 말이다. 그렇게 모든 철학자 쓰레드가 젓가락 하나만 가지고 있는 상태가 되면 프로그램은 돌아가지 않는다. 아무도 식사를 하지 못한 채로 정지되어 있게 된다. 이러한 상황을 starvation이 일어났다고 한다. 1번 쓰레드가 2번 쓰레드의 영향으로 실행을 못하는 상황인데 2번 쓰레드는 1번 쓰레드에 의해 실행을 못하게 되면 두 쓰레드 모두 실행을 하지 못하게 되는 상황이다. 이런 상태를 교착상태라고 한다. 영어로 Deadlock이다. 동기화를 세마포를 통해 설계를 하였는데 **교착상태**에 빠져 모든 자원이 임계구역에 접근을 하지 못하게 되는 것이다.





### 교착상태

프로세스는 실행을 위해 여러 자원을 필요로 한다. CPU, 메모리, 파일 등등 여러 자원을 사용하여 프로세스가 실행된다. 그러나 다른 자원을 갖지 못할 경우 대기 상태에 들어가서 기다려야한다. **자원은 한정되어 있는데 여러 프로세스가 같이 동작하는 상황이여서 발생하게된다.** 그러므로 운영체제는 프로세스에게 자원을 잘 할당해주어야한다. 그렇지않으면 철학자의 문제처럼 **교착상태** 에 빠질 수 있다.

![img](https://t1.daumcdn.net/cfile/tistory/26444B4858FAF76031)



교착상태 조건은 4가지 인다. 

**상호배타 ** : 하나의 프로세스가 자원을 사용할 경우 다른 프로세스는 그 자원을 사용할 수 없다.

**보유 및 대기 **: 프로세스가 자신이 가질 수 있는 자원은 가지고 있으면서 다른 자원이 오기를 기다리고 있는것

**비선점**: 프로세스 스케줄링에서 배운 단어와 같은 의미. 대신 여기는 CPU할당뿐만이 아니라 모든 자원에서 비선점이 된다. 

**환형(순환)대기** : 선형이 아닌 원형을 이루게 되어 프로세스 자원할당에서 첫번째 , 마지막 프로세스 자원할당이 겹치게 되어 원형의 모든 프로세스가 자원 할당을 받고자 기다리는 형태가 만들어진다.



**처리**

**교착상태는 모든 프로세스들이 필요한 자원을 할당 받지 못해 대기를 하고 있는 상태**

![img](https://t1.daumcdn.net/cfile/tistory/270DA73358FC58F207)

- 방지 : 한가지 이상을 불만족 시키는 방법 (하나만이라도 만족하지 못한 상태가 되면 교착상태는 발생하지 않기 때문)
- 회피 : 자원을 어떻게 잘 할당하여 줄 것인가 에대한 방식을 생각하는 것
- 검출및 복구 : 주기적 검사
- 무시  : 교착상태 발생하는 것에 준비하지 않는것 일어나면 모두 꺼버리고 재시동함



# 운영체제 tip

### synchronization 이란?

멀티 스레드에서 여러 스레드가 하나의 프로세스의 자원을 동시에 접근할 때 (critical region) race condition이 발생할 수 있으므로 스레드간에 동기화가 필요하다.

-> 경쟁 상황으로부터 보호하기 위해 한 순간에 하나의 프로세스만이 공유자료를 조작하도록 보장하는 작업 



### aging 기법이란?

기아현상(starvation) : 스레드에 cpu할당이 평등하게 배부되지 못하고 어떤 스레드드는 무한정 기다리는 현상이 발생함 

-> 에이징 기법: 기아현상을 해결하기 위한 기법으로 대기시간이 경과할 수록 우선순위를 높여주는 방법 -> HRN = SJH +aging 



- Critical Sction : 공용데이터에 접근하는 부분은 Critical Section 혹은 Critical Region이라고 부른다. 따라서 프로세스는 어떤 두 프로세스가 동시에 Critical Region 에 들어가지 않도록 한다면 race condition을 막을 수 있다.

### race condition 이란?

2개 이상의 프로세스가 공유 자원을 동시에 읽거나 쓸 때 발생하는 문제입니다.(프로세스끼리 하나의 자원을 갖기위해 싸우는 것 - 하나의 자원을 동시에 요청)

이 상황이 발생하게 되면 모든 프로세스에 원하는 결과가 발생하는 것을 보장할 수 없으므로 이러한 상황을 반드시 피해야한다.



-Mutual Exclusion : Race condition 을 해결하기 위해서는 **두 개 이상의 프로세스가 공용데이터에 동시에 접근하는 것을 막아야 한다.** 즉, 한 프로세스가 공용데이터를 사용하고 있으면 다른 프로세스가 그 자원을 사용하지 못하도록 막는다면 race condition 을 막을 수 있다.



### semaphore 설명? 구현?

공유자원에 접근할 수 있는 최대 허용치만큼 동시에 사용자가 접근할 수 있게 한다. mutex와 비슷하지만 가장 큰 차이는 **뮤텍스**는 동기화대상이 오직 하나뿐이지만 **세마포어**는 동기화대상이 하나이상일 때 사용한다.



```
int i = 0; //전역변수
i+=10; //스레드에의해 두번실행
```

ex> A,B 두개의 스레드가 동시에 위 코드를 실행한다면?

스레드는 stack을 제외한 영역을 공유한다. 

- 전역변수인 i는 data영영이므로 모든 스레드에 의해 접근가능하다 
- 프로세스는 context switching을 통해 할당시간을 나누는데, 스레드도 마찬가지므로, 동시에 실행하는 것 처럼 보이지만 CPU는 한순간에 하나의 스레드만 실행한다.
- A스레드는 메인메모리에 ` i=10`의 값을 저장한 후, 임시 메모리에 i=10의 값을 옮긴다. 그리고 10을 더하여 임시메모리값을 20으로 만들고 메인메모리에 저장하려고 하는데, 그 전에 할당받은 시간이 끝나 B스레드가 동작한다면? (context switching이 일어난것)
- A스레드는 다시 할당받기 전까지 다른 메모리공간으로 옮겨지고 B스레드가 실행된다.
- B는 위와같은 일을 반복한다. 임시 메모리에 10저장하고 더해서 20만들고 메인메모리 i값에 20을써준다. 
- 이제 메인메모리는 i = 20값이 써있다. 이제 context switching으로 중단되었던 A스레드가 마지막 작업인 임시메모리에 저장된 값을 메인메모리에 써주는 일을 한다. A스레드가 임시메모리에 20을 만들었으므로 A는 20이라는 값을 또 쓰는것 그려면 결과는 ` i= 20 `이된다.

--> context swiching을 연산단위로 하지 않고 시간단위로 나뉘었기 때문에 이런 문제가 발생한다. 



**동기화(synchronization)**매커니즘을 통해서 해결할 수 있다.

1. 공유된 메모리에 둘 이상의 스레드가 동시에 접근할때 생기는 문제점 (하나가 접근하는 동안 다른하나는 접근못하도록 막아줌)
2. 스레드 실행순서를 control  ex> A, B 스레드가 있을때, A는 데이터를 가져다놓는 스레드 B는 데이터를 가져가는 스레드라고 할때, 반드시 A스레드가 실행 된 후 B스레드가 실행되도록하여 실행순서를 제어하는 방법을 사용하면 된다.

이때 동기화하는데 있어서 **뮤텍스, 세마포어**를 사용한다.

뮤텍스

```
 #include<stdio.h>

   #include<unistd.h>
   #include<stdlib.h>
   #include<pthread.h> // 쓰레드,뮤텍스관련
  
   void * thread_increment(void * arg);
   char thread1[] = "A thread";
   char thread2[] = "B thread";
  
  pthread_mutex_t mutx;
  //전역변수 number선언
  int number=0;
 
  int main(int argc, char **argv){
      pthread_t t1,t2;
      void *thread_result;
      int state;
 
      //뮤텍스를 초기화 합니다.
      state = pthread_mutex_init(&mutx,NULL);
      if(state) puts("Error mutex initialization");
 
      //2개의 쓰레드를 생성합니다.
      pthread_create(&t1,NULL,thread_increment,&thread1);
      pthread_create(&t2,NULL,thread_increment,&thread2);
 
      //프로세스가 쓰레드 종료후 종료되도록 하는것
      pthread_join(t1,&thread_result);
      pthread_join(t2,&thread_result);
 
      printf("최종 number : %d\n",number);
      pthread_mutex_destroy(&mutx); //뮤텍스 종료함수입니다.
      return 0;
  }
 
  //쓰레드에 의해 실행되는 루틴
  void *thread_increment(void *arg){
      int i;
      for(i=0;i<5;i++){ //여기 for문을 critical section이라고 할수있다!
         pthread_mutex_lock(&mutx);//임계영역 들어가기전 뮤텍스를 걸어줌
         sleep(1); // 없어도됨
         number++;
         printf("실행 : %s, number : %d\n",(char *)arg,number);
         pthread_mutex_unlock(&mutx);//임계영역 나가며 뮤텍스 풀어줌
     }
 }
```



세마포어

```
 #include<stdio.h>

   #include<unistd.h>
   #include<stdlib.h>
   #include<pthread.h>
   #include<semaphore.h>
  
   void * thread_snd(void *arg);
   void * thread_rcv(void *arg);
 
  sem_t bin_sem; //세마포어~~
  int number = 0; //전역변수, 모든쓰레드 접근가능
 
  //세 개의 쓰레드
  //여기서 A쓰레드는 number를 1로만들고, B,C는 number를 0으로 만듭니다.
  char thread1[] = "A thread";
  char thread2[] = "B thread";
  char thread3[] = "C thread";
 
  int main(int argc, char **argv)
  {
      pthread_t t1,t2,t3;
      void * thread_result;
      int state;
 
      state = sem_init(&bin_sem,0,0); //초기화, 처음에 0으로설정
      if(state != 0) puts("Error semaphore initialization");
 
      //쓰레드를 생성합니다.
      pthread_create(&t1,NULL,thread_snd,&thread1);
      pthread_create(&t2,NULL,thread_rcv,&thread2);
      pthread_create(&t3,NULL,thread_rcv,&thread3);
 
      //프로세스가 먼저 종료되어 쓰레드가 중간에 종료되지않도록합니다.
      pthread_join(t1,&thread_result);
      pthread_join(t2,&thread_result);
      pthread_join(t3,&thread_result);
 
      printf("최종 number : %d \n",number);
      sem_destroy(&bin_sem); //세마포어 소멸
      return 0;
  }
 
  void * thread_snd(void * arg){
      int i;
      for(i=0;i<4;i++){
          while(number != 0) //만일 number가 0이 아니라면
              sleep(1); // number=0이될때까지 기다립니다.
          number++;
          printf("실행 : %s, number : %d\n",(char *)arg, number);
          sem_post(&bin_sem); //세마포어를 1로 만드는것!!
      }
  }
 
  void * thread_rcv(void * arg){
      int i;
      for(i=0;i<2;i++){
          sem_wait(&bin_sem); //세마포어를 0으로 만드는것!!
          number--;
          printf("실행 : %s, number : %d\n",(char *)arg, number);
     }
  }

 
```


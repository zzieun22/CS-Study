## list

[Chapter 1](#1장)  
[Chapter 2](#2장)  
[Chapter 3](#3장)  
[Chapter 4](#4장)  
[Chapter 5](#5장)  
[Chapter 6](#6장)  
[Chapter 7](#7장)  
[Chapter 8](#8장)  
[Chapter 9](#9장)  


## 1장
### **컴퓨터 시스템** 

### 1. 컴퓨터 시스템의 구성요소와 동작을 간략하게 설명하시오

"컴퓨터 시스템은 프로세서(CPU), 메모리, 입출력 장치(I/O)로 구성되어 있습니다.
프로세서(CPU)는 컴퓨터의 각 부분의 동작을 제어하고 연산을 수행하는 핵심부분이며,
 메모리는 데이터를 저장하는 공간입니다. 키보드, 마우스, 스캐너와 같은 입출력 장치(I/O)로부터
정보를 전달받으면 메모리에 해당 정보를 저장합니다.
저장된 데이터는 프로그램이 실행되면서 CPU의 제어에 따라 연상 장치에서 처리가 되고,
이렇게 처리된 정보는 출력 장치를 통해 표시가 되거나 디스크에 저장됩니다."  
//  
"  컴퓨터 시스템은 가장 크게 CPU, 메모리, IO로 구성되어 있습니다.  
CPU안에는 연산장치와 제어장치 그리고 고속 저장장치인 레지스터가 있습니다.
메모리는  바이트와 워드 단위로 자료를 저장하는 RAM과 ROM이 있으며, CPU와 메모리를
연결시켜주는 통로인 버스가 있습니다. 마지막으로 IO장치로는 프린터,모니터,마우스 등 다양한 
입출력 장치들이 존재합니다.  
여기서, 버스는 세가지의 종류기 있는데 데이터버스/주소버스/제어 버스 등이 있습니다.
레지스터는 전용 레지스터와 범용 레지스터가 존재하며, 목적을 갖는 하나의 중간 값을 저장합니다.  
저장 장치 종류로는 속도가 빠른 순서대로, 레지스터, 캐시, 메인메모리, 보조기억장치가 있고 보조 기억장치를 제외한
세가지의 메모리는 프로세서가 프로그램과 데이터에 직접 접근할 수 있습니다.  
컴퓨터 시스템의 동작은 디지털 형태의 정보를 입력 받아, 메모리(기억장치)에 저장된 명령어 목록(프로그램)에 따라 
처리, 결과를 출력하며 동작하게 됩니다.
여기서 명령어는 연산 코드와 오퍼랜드 코드로 구성이 되어있으며, 실행전에 메인 메모리에 저장되고 한번에 하나의 명령어가
프로세서에 전송되어 해석을 하고 실행하게 됩니다. 
명령어의 실행과정으로는 명령어 레지스터에 저장된 다음 명령어를 인출한 다음 인출한 명령어를 해석하고 다음 명령어를
지정하려고 프로그램 카운터를 변경합니다. 그 다음 명령어가 메모리에 있는 워드를 한 개 사용하려면 사용 장소를 결정하여
피연산자를 인출하고 필요하면 프로세서 레지스터를 보냅니다. 그 다음 명령어를 샐항하고 결과를 저장해 다음 명령어로 이동하여 다시 
명령어를 인출하는 과정으로 진행됩니다. "

### 2. 인터럽트는 무엇이고 언제 실행 되는가?
"인터럽트는 컴퓨터에 설정된 장치에서 프로세서(CPU)로 보내는 하드웨어 신호입니다.
현재 실행 중인 프로그램의 수행을 미루고 다른 프로그램의 수행을 요구하는 명령입니다. 
인터럽트가 걸리면 인터럽트를 받은 장치는 현재 자신의 상태를 기억해두고 언터럽트 처리를 진행합니다.
시스템 콜도 인터럽트의 한 종류입니다.
  
인터럽트는 갑작스런 정전이나 I/O 장치로부터 처리를 요청받거나
시스템이 예측하지 못한 사용자읭 비력이 발생 했을때, 잘못된 명령어가 수행되었을 때 발생합니다. "


### 3. 인터럽트의 장점은 무엇인가?
"프로세서가 이벤트가 발생했는지를 감시하지 않고 인터럽트가 일어났을 때만 처리해주면 되므로 
다른 연산을 수행하여 프로세서의 효율을 높일 수 있습니다. "
### 4. 인터럽트는 어떻게 처리되는가?

"인터럽트가 발생하면 현재 명령어를 종료하고 리제스터의 모든 내용을 스택 영역에 저장합니다.  
PC에는 인터럽트 처리 프로그램의 시작 위치를 저장하고 인터럽트 요청을 보내온 프로그램에 제어를 넘겨 처리합니다. 인터럽트 처리가 완료되면 스택 영역에 있던 내용을 레지스터에 다시 저정하며, 
원래 수행하던 프로그램을 재실행 합니다."

### 5.컴퓨터의 메모리 구조는 왜 계층적으로 구성되었는가?

여러 레벨의 메모리가 연결되어 비용, 속도, 용량, 접근 시간 등을 상호 보완할 수 있다.

### 6. 프로세서와 프로세스를 구분하여 설명하라.

"프로그램은 디스크에 저장된 파일과 같은 수동적인 개체이고, 프로세스는 
실행중인 프로그램으로 메모리와 CPU등의 컴퓨터 자원을 할당 받고 프로그램을
실행할 수 있는 능동적인 개체이다. 즉 프로그램이 주기억장치에 적재되어 처리를 
시작할 때 비로소 프로세스라는 활동적인 개체가 된다.(Program in Execution)"

[OS_list](#list)

# 2장 
### **운영체제** 

### 1. 운영체제가 어떤 시스템인지 간략하게 설명하라
"운영체제는 프로그램을 실행하는데 필요한 환경과 자원을 제공하고 관리하기 위한 시스템이다. 
하드웨어(CPU), 메모리 및 입/출력(I/O 장치)를 관리한다.   
사용자가 컴퓨터를 사용하기 (1) 편리한 환경을 제공하고, (2) 입출력 장치의 동작을 관리하고 제어하고
(3) 시스템의 오류를 예방하며, 컴퓨터의 다양한 자원들을 필요한 작업들에게 (4) 자원을 할당하는 자원 할당자의 역할을 한다. "
### 2. 커널이란 무엇인가
"커널은 운영체제의 핵심 부분으로 하드웨어와 관련된 내부적 역할을 담당한다.
운영체제의 다른 부분 및 응용 프로그램 수행에 필요한 여러가지 서비스를 제공하는 역할을 하며,
메모리나 저장장치 내에서 운영체제의 주소 공간을 관리한다.  
커널의 주요 역할은 컴퓨터 하드웨어와 프로세스의 보안을 책임지는 '보안',
한정된 시스템 자원을 효율적으로 관리하여 프로그램의 실행을 원활하게 하는 '자원 관리',
비슷한 종류의 하드웨어에 공통된 명령어를 제공하는 '추상화' 기능이 있다."
### 3. 시스템 호출이란 무엇인가
"시스템 호출은 프로세스가 운영체제와 통신하기 위한 유일한 방법이다.  
운영체제가 제공하는 다양한 서비스들이 동작하기 위해 응용 프로그램 개발자들이 응용 프로그래밍 인터페이스에 따라서 프로그램을 설계한다.  
개발자는 내부적으로 어떤 작업이 이루어지는지 알 필요가 없으며, 단지 API를 준수하고 시스템 호출의 결과로 운영체제가 어떤 작업을 해주는지 이해하면 된다."
### 4. I/O의 개선 방안으로 버퍼링과 스풀링에 대해 각각 설명하라
"CPU의 처리 속도와 입출력 장치의 속도 차이를 보완하기 위한 방법으로 버퍼링과 스풀링이 고안되었다.
 버퍼링은 입출력 장치의 느린 속도를 개선하기 위한 방법이다. CPU가 하나의 입출력 작업이 완료되기를 기다리지 않고 여러 작업을 버퍼에 저장해 입출력 장치가 버퍼로부터 작업을 처리하게 함으로써 CPU가 입출력 장치의 속도와 관계없이 연산 처리가 가능하도록 하였다.  
 스풀링은 CPU와 입출력 장치 사이의 속도 차이를 해소하기 위한 방법이다. 하드 디스크의 일부를 프린트 작업을 위한 스풀 공간이라고 부르는 매우 큰 버퍼처럼 사용하여 CPU가 이전 작업의 프린트 출력 완료를 기다리지 않고 다른 작업을 읽어들일 수 있기 때문에, 출력 시간 동안 또 다른 작업이 수행될 수 있다. 
간단한 버퍼링에 비해 스풀리의 장점은 한 작업의 입출력과 다른 작업의 계산을 중복할 수 있다는 것이다. 버퍼링은 한 작업의 입출력과 그 작업의 계산만 중복할 수 있는데 반해, 스풀링은 많은 작업의 입출력과 계산을 중복 시킬 수 있다."
### 5. 부팅의 동작 흐름을 설명하라

"부팅이란 pc에 전원이 들어온 후 운영체제가 실행되기 전의 과정이 이야기한다.  
이 과정에서 초기화 작업과 운영체제제를 로딩해오는 작업을 주로 수행한다.  
부트스트랩 프로그램 또는 부트스트랩 로더로 알려진 작은 크기의 코드가 커널을 찾아서 주 메모리에 적재하고 커널의 실행을 시작한다."

[OS_list](#list)

# 3장
### **프로세스와 스레드** 

### 1. 프로세스란 무엇인가?
"실행되고 있는 프로그램의 개체. 하나의 프로세스에서 여러 프로세스 생성 가능하다   
운영체제가 자원을 할당하는 기본적인 단위/ 다른 프로세스와 상관없이 독립적으로 자원을 할당 받음
"

### 2. 프로세스 상태도를 보고 프로세스의 상태를 설명 할 수 있는가?
"생성:   
프로세스를 시스템에서 생성하는 단계 PCB를 커널에 저장하고 실행할 준비가 되었다는 뜻이다.  
준비:   
프로세스를 실행하기 위해 CPU를 배정받기를 기다리는 상태이다. 할당받으면 바로 실행
실행:   
프로세스가 CPU를 할당받아 실제로 실행되는 상태(명령어가 실행됨)  
 -dispatch(준비상태의 프로세스가 cpu를 할당받아 run 상태로 전이되는 과정  
 -time runout (run 상태의 프로세스에 할당된 cpu 사용시간이 완료되어 ready 상태로 되돌아가는 과정
대기 :  
프로세스가 어떤 사건이 발생하기를 기다리고 있는 상태( 이벤트나 입출력 신호가 발생하면 대기상태로 간다 완료 후 나머지 부분 실행을 위해  준비상태로 )
종료:  
프로세스 실행이 끝나고 cpu 할당이 해제된 상태
"

### 3. 문맥교환과 프로세스 제어 블록(PCB: Process Control Block)에 대해서 설명해보아라
"PCB:   
프로세스가 실행될때 모든 동적인 정보를 기록해 두는 자료구조.
프로세스가 만들어질 때 각 프로세스별로 생성 되고 종료시 해당 PCB도 삭제된다.
커널은 PCB를 통해서 프로세스를 관리한다. 준비/대기리스트는 pcb리스트이다.
문맥교환:     
멀티프로그래밍 환경에서 하나의 프로세스가 CPU를 사용중인 상태에서 다른 프로세스가 
CPU를 사용하게 만들기위해 이전 프로세스상태(문맥: 프로세스 실행을 위한 모든정보)을 보관(저장)하고 
새로운 프로세스상태를 적재하는 작업 . (시분할방식을 사용한다.)
"
### 4. 스레드란 무엇인가?
"경량프로세스라고도 불린다. 프로세스 내에서 실행되는 흐름의 기본단위를 말한다.   
프로그램 명령을 실행하는 프로세스 내의 개체이다.   
기존 프로세스:   
fork()등의 API를 통해 생성/ 독립적으로 실행되며 별개의 메모리를 차치함
스레드:   
지역변수 저장용 메모리(스택)만 별도 할당 pthread_create()를 통해 생성/ 
프로세스의 상태변화를 따르며 실행된다. 멀티스레드는 프로세스내에 메로리를 공유해 사용할 수 있다. /
생성시에 오버헤드가 적다.
"

### 5. 운영 체제의 스레드 지원 방식을 설명하고 장단점을 설명해보시오
"사용자 수준의 스레드 :   
커널은 프로세스만 인식하여 CPU를 할당한다. 
그래서 커널은 프로세스 정보를 커널에 저장하고 각 프로세스가 스레드 정보를 저장함/ 
스레드의 입출력에 의한 대기 시 , 전체 스레드가 대기된다. ==> 높은 이식성, 스케줄링의 유연성 , 동시성지원 불가, 병행처리 불가  
커널 수준의 스레드 :  
커널이 스레드를 인식하여 각 스레드별로 CPU할당함, 
CPU가 다수이면 한 프로세스내의 다수 스레드에게 각각 CPU할당이 가능하다. 
병행실행을 통한 실행속도 증가. 1스레드 = 1CPU할당 ==> 시스템 성능향상 병행실행 가능, 자원이 많이 필요함
혼합형 : 스레드를 생성하는 시점에서 스레드 수준을 결정"

[OS_list](#list)

## 4장
### **병행 프로세스와 상호배제** 

### 1. 상호 배제의개념과 조건을 설명하시오
특정 공유자원을 한 순간에 하나의 프로세스만 사용할 수 있을때, 프로세스 하나가 공유데이터에 접근하는 동안 다른 프로세스가 해당 데이터를 접근할 수없게 하는것 (임계구역으로 불리는 코드 영역에 의해 구현된다.)  while(1) { ... BeginCriticalSection();  ... EndCriticalSection(); }  여기서 임계영역은 상호배타적으로 실행되고 임계영역 안에 있는 프로세스는 빨리 수행되어야 하며, 블록상태가 되어서는 안된다.  
상호배제조건: 두 개 이상의 프로세스들이 동시에 임계영역에 있어서는 안된다.

### 2. 뮤텍스와 세마포어에 대해 기술하시오
뮤텍스는 상호배제로 임계영역을 가진 스레드들이 running time이 서로 겹치지 않게 단독으로 실행 되게 하는 기술이다. 두 스레드가 동시에 사용될 수 없다는 의미   
세마포어 : 세마포어는 동시에 리소스에 접근할 수 있는 ‘허용가능한 counter의 갯수’ 를 가지고 있는 카운터로 보면된다. Counter 갯수만큼 공유자원에 접근할 수 있다 binary semaphore 는 결국 뮤텍스와 같다고 볼 수 있음. 

### 3. Bakery알고리즘이란 ? 
N개 이상의 프로세스의 상호배제가 되도록 구현하는 방법, 프로세스에게 먼저 온 순서대로 번호표를 부여하고 그 번호가 우선인 프로세스부터 작업을 시켜주는 것, 만약 두 프로세스가 동시에 접근하여 번호표가 같아진다면 프로세스 번호가 낮은 순서로 우선순위를 정하여 상호간의 연산에 있어서 간섭이 일어나지 않도록 하는 방법

[OS_list](#list)

## 5장
### **교착 상태와 기아 상태** 
### 1. 교착상태에 대해서 설명하시오
 시스템에 있는 프로세스들이 영속적으로 블록상태에 들어가거나 둘 이상의 프로세스들이 공유자원에 대한 경쟁이나 통신 중에 발생하는 상태를 말한다.
### 2. 데드락(교착상태)가 발생하는 4가지 조건을 설명하시오.
1. 상호 배제 (Mutual exclusion)    
2. 점유 상태로 대기 (Hold and wait)   
3. 선점 불가 (No preemption)4. 순환성 대기 (Circular wait)이 4가지 조건이 모두 만족되면 교착 상태가 일어나게 된다.

### 3. 데드락(교착상태)의 해결방안 4가지를 설명하시오.

"1) 데드락의 예방(Prevention)  
위 4가지 조건은 동시에 충족돼야 데드락이 발생한다. 그러므로 그 중 하나라도 발생하지 않도록 시스템 차원에서 막아버리면 해결된다.
근데 이 방법은 대부분 자원이 낭비되는 경향이 있다. 그리고 애초에 발생 가능성을 원천봉쇄하려면 성능이 나빠지거나 또 다른 문제를 발생시킬 수 있다.

2) 데드락의 회피(Avoidance)   
교착상태의 원칙적인 발생 가능성(조건)은 그냥 냅두고, 발생을 막는 알고리즘을 적용해서 해결하는 방법.
은행원 알고리즘(프로세스가 자원을 요구하는 시점에 자원을 할당해도 안전한지를 검사하여 데드락을 막는 방법)
자원할당 그래프 알고리즘(아직 이건 모름. 추후 찾아볼 예정)

3) 데드락의 탐지(Detection)와 회복(Recovery)  
교착상태가 발생하는 것을 아예 막지조차 않음. 발생하면 그때서야 해결하겠다는 방법.
"

[OS_list](#list)

## 6장
### **단일 프로세서(cpu) 스케줄링** 
### 1. 스케줄링이 왜 필요한지 설명하시오
"스케줄링은 CPU 작업과 입출력 작업을 병행하는 다중 프로그래밍이 가능해지면서 필요해졌다.
입출력 작업을 하고 있는 프로세스(활성화된 프로그램)의 경우는 점유하고 있던 CPU에서 디스패치되면서 대기 상태로 전환된다. CPU가 쉬지 않도록  대기하고 있던 프로세스들 중 다음에 작업할 프로세스를 선택하여 CPU를 할당해주어야 한다.  
어떤 특별한 조건으로 다음 프로세스를 선택하는 것을 스케줄링이라고 하며
프로세스가 기아상태에 빠지지 않거나 너무 늦게 할당되지 않도록 다양한 측면을 고려해 다음 프로세스를 선택해야만 한다. "

### 2. 선점, 비선점 스케줄링의 차이를 설명하시오 
"비선점 스케줄링은 현재 실행중인 프로세스의 CPU를 강제로 빼앗지 않는 스케줄링 기법이다. CPU를 점유하고 있는 프로세스가 자진해서 CPU를 반납할 때까지 CPU의 사용을 보장한다.   
선점 방식보다 스케줄러의 호출 빈도가 낮고 문맥교환으로 인한 오버헤드도 적다. 따라서 일괄처리 시스템에 적합하다. CPU 사용 시간이 긴 하나의 프로세스가 CPU 사용 시간이 잛은 여러 프로세스를 오랫동안 대기하게 할 수 잇으므로 처리율이 떨어질 수도 있다.  
대표적인 스케줄링으로는 FCFS(First-Come-First-Served), 최단 작업 우선(Shortest Job First: SJF), HRN 스케줄링이 있다.  
선점 스케줄링은 현재 실행 중인 프로세스의 CPU를 강제로 빼앗는 스케줄링이다.   
대표적인 스케줄링으로는 SRTF(Shortest Remaining Time First), 우선 순위 스케줄링, 라운드로빈 스케줄링(RR), 다단계 큐 스케줄링, 다단계 피드백 큐 스케줄링이 있다."  
### 3. 라운드 로빈 스케줄링에 대해 설명하시오
"라운드 로빈 스케줄링은 시분할 시스템을 위해서 설계된 스케줄링의 하나이다.   
프로세스들 사이에 우선 순위를 두지 않고, 순서대로 시간단위(time slice, time quantum)로 cpu를 할당하는 방식의 알고리즘이다. 시간 단위동안 수행한 프로세스는 준비 큐에 다시 들어가서 다시 실행되기를 기다린다.  
문맥 전환의 오버헤드가 큰 반면, 응답 시간이 잛아지는 장점이 있다. "

[OS_list](#list)

## 7장
### **메모리 관리** 
### 1. 메모리 관리가 왜 필요한가

한정적인 메모리의 크기를 효율적으로 관리하여 쾌적한 프로그래밍과 overhead를 최소화하여 성능을 극대화하기 위해 필요한 기능이다.

### 2. 스와핑이 일어나는 이유와 그 과정에 대해서 설명하시오
OS의 멀티테스킹을 위하여 프로세스 간의 문맥 전환이 일어날 때, 메모리의 효율적인 관리를 위하여 스와핑을 해준다.  
스와핑이란 주기억장치에 적재한 하나의 프로그램과 보조기억장치에 적재한 다른 프로그램의 메모리를 교체하는 기법으로,
하드디스크로 이런 프로세스의 문맥 정보를 옮기는 것을 Roll Out(롤 아웃), 반대로 재개되는 프로세스의 문맥 정보를 읽어서 
메모리로 가져오는 것을 Roll In(롤 인)이라고 한다.   
이러한 스와핑은 보조 메모리를 필요로 하며 보통 디스크를 사용한다. 시스템은 실행 준비가 된 모든 프로세스를 모아 
준비 완료 큐(Ready queue)에 가지고 있어야 하고, CPU가 스케줄을 고를 때 디스패처(dispatcher)를 호출한다. 
디스패처는 준비 완료 큐(Ready queue)에 있는 다음 프로세스가 메모리에 올라와 있는지 확인하여 메모리에 없다면 
디스크로부터 읽어 들인다. 이 때, 만약 메모리에 이 프로세스에 대한 공간이 없다면, 공간을 만들기 위해 현재 메모리에 
올라와 있는 프로세스를 내보내고(swap out) 원하는 프로세스를 불러들인다. 그리고 나서 CPU의 모든 레지스터를 
실행해야 할 프로세스의 것으로다시 적재하고 제어권을 그 프로세스에게 넘긴다. 

### 3. 메모리를 할당하는 두가지 방법 중, 연속된 공간에 메모리를 할당하는 방법에 대해서 설명하고, 연속적으로 메모리를 할당하기 위해 메모리를 분할하는 두가지 방법에 대해서도 함께 설명하시오 (고정 분할/가변 분할)

실행될 프로그램은 연속적인 메모리 공간을 할당 받아 전체 코드와 변수가 메모리에 적재되어 사용한다. 방법으로는 '고정 분할'과 동적 분할' 기법이 있으며, 만약 프로그램이 너무 큰 경우는 실행이 불가능히다. (다시 작성하거나 overlay 방식으로 재구성을 해야함. )

고정 분할(정적 분할)기법이란, 메모리를 여러 개의 고정된 크기로 분할하는 기법으로, 프로세스가 요청한 크기에 맞는 분할된 메모리를 할당한다. 때문에 구현이 간단하고, 운영체제의 오베이드가 거의 없지만 내부 단편화가 일어나며, 최대 활성 프로세스가 고정되는 단점이 있다.  
가변(동적) 분할이란, 프로세스가 필요한 만큼의 메모리를 할당하기 위해 고정된 경계를 없앤 방법으로, 각 프로세스는 필요한 만큼의 메모리를 할당한다.  때문에 메모리 전체를 하나의 연속된 공간으로 처리하여 내부 단편화를 줄일 수 있지만 외부 단편화가 발생한다는 단점이 있다."

### 4. 단편화가 생기는 원인을 설명하시오 (내부단편화, 외부 단편화)
메모리의 공간이 작은 조각으로 나뉘어져 사용 가능한 메모리가 충분히 존재하지만 할당이 불가능할 때 메모리 단편화가 일어난다.   
내부단편화는,  메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어서 프로세스에서 사용하는 메모리 공간이 낭비될 때 일어난다. 외부 단편화는, 메모리가 할당되고 해제되는 작업이 반복될 때 생긴 사용하지 않는 메모리가 많이 존재해서 총 메모리 공간은 충분하지만 실제로 할당할 수 없는 상황에 발생하게 된다.

### 5.외부 단편화 문제를 해결하는 방법으로 압축이 있다. 이에 대해 설명하라

사용하지 않는 작은 메모리리 간들을 합하여 연속된 빈 공간을 만드는 작업으로, 매모리 내용을 적절히 움직여 사용 가능한 공간을 큰 블록 하나로 만드는 것을 의미한다.
 
### 6. 가변 분할에서 프로세스에게 빈 메모리 공간을 배치하는 방법 3가지를 설명하시오(최초 적합 방법, 최상 적합 방법, 최악 적합 방법)

가변 분할에서서는 정해진 작업의 코드 크기에 대해 메모리의 빈 여러 공간 중에서 어느 공간에 배치할 지를 결정한다.   
이 때, 배치 방법 중 '최초 적합 방법'으로는 메모리의 가장 작은 번지의 공간부터 검색하여 가장 먼저 찾은 빈 공간에 프로그램을 할당하고,
'최상 적합 방법'으로는 메모리에 있는 모든 빈 공간을 검색하여 요청한 크기에 가장 가까운 빈 공간에 프로그램을 할당한다.  
마지막으로 '최악의 적합 방법'으로는 메모리에 있는 모든 빈 공간 중에서 가장 큰 공간에 프로그램을 할당한다.


### 7. 페이지와 세그먼테이션에대해 설명
"페이징 기법은 가상 메모리를 사용하고 외부 단편화를 해결하지만 내부 단편화가 존재한다.  
보조기억장치를 이용한 가상 메모리를 같은 크기의 블록으로 나눈 것을 페이지라 하고, 
메모리를 페이지와 같은 크기로 나눈 것을 프레임이라 한다.  
이 때, 페이징 기법이란 사용하지 않는 프레임을 페이지에 옮기고, 필요한 메모리를 페이지 단위로
프레임에 옮기는 기법을 말한다. 페이징 기법을 사용하면 연속적이지 않은 공간도 활용할 수 있기 때문에
외부 단편화 문제를 해결할 수 있다. 하지만 페이지 단위에 알맞게 쓰는 것이 아니기 때문에
내부 단편화 문제가 여전히 남아 있다.

세그멘테이션 기법은 가상 메모리를 사용하고 내부 단편화를 해결하지만 외부 단편화가 존재한다.
페이징기법에서 가상메모리를 같은 크기의 단위로 분할했지만 세그멘테이션기법에서는 가상메모리를
서로 크기가 다른 논리적 단위인 세그먼트로 분할해서 메모리를 할당하여 실제 메모리 주소로 변환하게 된다.  
이 때 각 세그먼트는 연속적인 공간에 저장되어 있는데, 각각의 크기가 다르기 때문에 미리 분할할 수 없고,
메모리에 적재될 때 빈 공간을 찾아 할당하는 기법이다.  
프로세스가 필요한 메모리만큼 할당해주기 때문에 내부단편화는 일어나지 않으나, 여전히 중간에
프로세스가 메모리를 해제하면 생기는 구멍, 즉 외부 단편화의 문제는 여전히 일어난다."

[OS_list](#list)

## 8장
### **가상 메모리** 
### 1. 가상 메모리의 개념은? (논리/물리주소, 사상)

가상메모리란? RAM을 관리하는 방법의 하나로, 각 프로그램에 실제 메모리주소가 아닌 가상의 메모리 주소를 주는 방식을 말한다.  그 중 가상적으로 주어진주소, 프로세스가 참조하는 주소를 가상주소라고 하며, 실제 메모리상에서 (메인메모리) 유효한 주소를 물리주소 또는 실제주소라고 한다.  사상(mapping)을 통해서 가상주소를 실제 주소로 변환한다.  (블록단위로 사상한다 -> 사상관련 정보를 줄이기 위해)   
블록크기가 일정하면 페이징시스템 / 블록크기가 다양하면 세그먼트 시스템으로 분리된다.

### 2. 페이지 교체 알고리즘에 따른 페이지 폴트 횟수구하기 fifl lru,lfu 설명 
FIFO : 메모리에 먼저 올라온 페이지를 먼저 내보내는 알고리즘 , 가장 오래 머물렀던 프레임을 선택하여 대치한다.  프레임 수가 적을수록페이지 결함이 더 많이 일어나게 된다. 계속 교체를 해주어야하기 때문이다. 하지만 프레임의 수가 많아질수록 결함의 횟수는 감소하게 된다.                                                                             
LRU: 최근에 사용하지 않은 페이지를 가장먼저대치시키는 방법(최근까지 사용안하면 미래에도 사옹되지않을 거라는 가정) 과거를 보고 판단. LRU는 H/W의 지원을 필요로 하지만 대부분 시스템은 HW지원을 하지 않는다. OPT : 앞으로 가장 오랫동안 사용되지 않을 페이지를 선택하여 페이지 교체한다. 낮은 페이지 부재율이 라는 장점이 있지만 구현이 어렵다.

[OS_list](#list)

## 9장
### **입출력 시스템과 디스크 관리** 
### 1. fcfs , sstf , scan look 스케줄링 장단점 설명하시오
"FCFS (First Come First Served) :먼저 들어온 요청부터 처리한다.  
  - 장점 : 요청들이 순서대로 처리되므로 공평성 보장, 프로그래밍도 편함  
  - 단점 : 디스크의 오버헤드가 커지면 응답시간이 길어져서 효율이 낮다.  
SSTF (Shortest Seek Time First) : 현재 디스크의 헤드 위치에서 가장 가까운 실린더에 대한 요청을 우선적으로 처리한다.   
  - 장점 : FCFS보다 처리량이 많고 평균 응답시간이 짧다  
  - 단점 : 실린더의 제일 안쪽과 바깥쪽 트랙이 기아 상태가 발생할 수도 있다.  
SCAN (= elevator algorithm) : 디스크의 한 쪽 끝에서 반대쪽 끝으로 이동하면서 처리하며, 마지막 실린더에 도착하면 반대 방향으로 스캔을 진행한다. 실제로 구현되는 대부분의 디스크 스케줄링의 기본 전략이다.
  - 장점 :  새 요청도 헤드가 이동하는 길에 데이터가 있으면 처리됨  
  - 단점 : 밖 트랙이 안쪽 트랙보다 더 적은 서비스를 받을 수도 있음    
C-SCAN : 디스크의 한 쪽 끝에서 반대쪽 끝으로 이동하면서 처리하며, 마지막 실린더에 도착하면 시작점으로 되돌아간 후 다시 스캔을 진행한다.    
  - 장점 : 안쪽과 바깥 쪽 실린더의 차별 대우가 사라짐, 응답 시간의 편차가 아주 작다  
LOOK : 움직이는 방향의 앞으로 더 요청이 없으면 멈추고 다시 반대 방향으로 헤드를 움직인다.  
  - 장점 : 불필요한 seek 연산을 하지 않게 되므로 효율적, 처리율이 높음"  

### 2. 디스크 스케줄링의 목적은 무엇인가?
디스크 스케줄링은 디스크에서 찾고자 하는 데이터가 여러 곳에 흩어져 있을때 데이터를 찾기 위해 헤드를 어떻게 움직일지를 결정하는 작업이다.   
다양한  디스크 스케줄링 방법을 고안하는 것은 디스크로 들어오는 요청 처리율을 높이고 평균 반응 시간과 분산 반응시간을 최소화하기 위해서이다. 

[OS_list](#list)

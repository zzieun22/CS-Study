- **작성자** : 박지은
- 모든 개발자를 위한 HTTP웹 기본지식(인프런)

## 목차

[1.인터넷 네트워크 ](#인터넷_네트워크  )

[2. URL와 웹브라우저 요청 흐름](#URL와_웹브라우저요청흐름)

[3. HTTP 기본](#HTTP기본)

# 인터넷_네트워크 



## IP

IP주소 부여를 각각 해줘야한다.

 **인터넷 프로토콜의 역할** 

- 지정한 IP주소로 데이터 전달

- 패킷이라는 통신단위로 데이터 전달

![패킷전달](https://user-images.githubusercontent.com/36434665/115109695-4e34a480-9fb2-11eb-9340-278a14834547.png)

출발지 목적지를 이해해서 노드끼리 던진다. 

200.200~ 목적지로 도달 

![패킷전달2](https://user-images.githubusercontent.com/36434665/115109831-24c84880-9fb3-11eb-95ce-23fed33db0ab.PNG)



### IP 프로토콜의 한계가 있다. 

- 비연결성 
  - PC가 꺼져있다면? 대상이 없어도? 전달한다.

- 비신뢰성 
  - 패킷이 중간에 사라지면?
  - 패킷이 순서대로 안오면? 
- 프로그램 구분
  - 같은ip사용하넌 서버에서 통신하는 애플리케이션이 둘 이상이면?



## TCP

![프로토콜 계층](https://user-images.githubusercontent.com/36434665/115109830-21cd5800-9fb3-11eb-9299-fc079c4c7e9e.PNG)**IP패킷** 정보는 출발지 목적지 등등 정보가있음 

**TCP/IP패킷** 정보에는 출발지 port, 목적지post, 전송제어 , 순서 검증 정보등이들어간다. 

### TCP 특징

- 연결지향 -TCP <u>3way handshake</u> > 연결을 먼저 하고, 메세지를 보낸다.

- 데이터 전달보증

- 순서보장 

- 신뢰할 수 있는 프로토콜
- 시간이 걸린다.



### UDP 특징

- 하얀 도화지에 비유(기능이 거의 없다)
- 연결지향  -TCP <u>3way handshake</u> x
- 데이터 전달보증 x
- 순서보장 x
- 데이터 전달및 순서가 보장x 단순하고 빠름 
- port만 추가된다. 체크섬 정도만 포함
- 애플리케이션에서 추가작업 필요
- http 3에서 사용한다.



## Port

### 한번에 둘 이상 연결하려면? 

게임 , 화상통화 등등에서 온 패킷인지 모름 

- ip는 목적지를 찾는것 

- port는 목적지 안에 애플리케이션을 찾는 것 





# URL와_웹브라우저요청흐름

## URI

리소스를 식별하는 통합된 방법

URI는 로케이터(URL),이름(URN) 또는 둘다 추가로 분류될 수 있음 

#### URL

Locator 리소스가 있는 위치를 지정

#### URN

Name : 리소스에 이름을 부여 





## 웹브라우저 요청 흐름 



https://www.google.com:443/search?q=hello&hl=ko



www.google.com:443 

1. DNS 조회 : 200.200.200.2

2. HTTP port : 443



**HTTP 요청 메세지 ** 가 만들어짐 

```
GET /search?q=hello&hl=ko HTTP/1.1
Host : www.google.com
```

![http흐름](https://user-images.githubusercontent.com/36434665/115863590-a6ffb380-a470-11eb-851f-299198d46cfd.PNG)

1. 아이피랑 호출정보 찾아서 구글서버랑 연결 후 전달

2. TCP IP 패킷 정보 추가 
3. 구글서버에 요청 패킷 도착 

**HTTP 응답 메세지**를 받게 된다. 

```
HTTP/1.1 200 OK // 정상 응답 
Content-Type:text/html;charset=UTF-8 // 응답 형식등등 
Content-Length:3423
<html>
< body></body>
</html> >> 데이터가 들어와서 랜더링 
```



# HTTP기본



## HTTP

### 기반 프로토콜 

- TCP : HTTP/1.1 , HTTP/2
- UDP : HTTP/3
- 현재 HTTP/1.1주로 사용 



### HTTP 특징 

- 클라이언트 서버 구죠
- 무상태 프로토콜 . 비연결성
- HTTP 메세지
- 단순함, 확장가능 



## 클라이언트 서버 구조

- Request Response 구조
- 클라이언트는 서버에 요청을 보내고 응답대기
- 서버가 요청에 대한 결과를 만들어서 응답 

클라이언트/서버를 분리하는게 중요하다.



## 무상태 프로토콜 (staeless)

### stateful , stateless 차이 

**stateful**

- 서버가 이전 상태를 보존한다. 
- 서버가 장애가 나면? 클라이언트는 처음부터 다시 시작해야한다.

**stateless**

- 서버가 이전상태를 보존하지 않는다.

- 서버가(고객이) 필요한 데이터를 그떄그때 넘겨준다. 
- 클라이언트 요청이 증가해도 서버를 대거 투입할 수 있다.

- 응답서버를 쉽게 바꿀 수 있다.(무한한 서버 증설 가능)- 스케일아웃
- 서버1,2,3중 아무거나 선택해서 요청하면 응답할수있다.



## 비연결성

- HTTP는 기본이 연결을 유지하지 않는 모델 
- 일반적으로 초 단위의 이하의 빠른 속도로 응답
- 서버자원을 효율적으로 사용할 수 있음 
- 수천명이 서비스를 사용해도 > 서버에서 동시에 처리하는 요청은 수십개 이하로 작음 

### 한계와 극복

- TCP/IP연결을 새로 맺어야한다. 3way handshake시간 추가
- 웹즈라우저 사이트 요청하면 HTML, JS, css등 수많은 자원이 함께 다운로드
- HTTP지속연결로 문제 해결 
- HTTP/2 , /3에서 많은 최적화

**HTTP초기** 

연결 > html 응답 <  종료

연결 > js 응답 <  종료

연결 >이미지 응답 < 종료



**HTTP 지속연결** 

연결> html응답 < js 응답<이미징 응답<종료



## HTTP메세지

메세지 구조

| ----                      |
| ------------------------- |
| start -line 시작라인      |
| header 헤더               |
| empty line 공백라인(CRLF) |
| message body              |

요청 메세지 , 응답 메세지 

![image](https://user-images.githubusercontent.com/36434665/127728288-59d2ec9e-8cf2-47de-baeb-a35209644f4e.png)

### 요청 메세지

**start -line 시작라인** 

- get/post등 method , path(절대경로 / 로시작하는 경로) , version 이 들어간다.

### 응답 메세지

**start -line 시작라인** 

- HTTP 버전, 상태 코드 

- 상태 코드

  200성공 

  400클라이언트 오류 

  500 서버 내부 오류 

**헤더** 

- file name: 
- 용도 : HTTP 전송에 필요한 모든 부가정보가 다 들어가있다. 
  - html, xml 설명 , body 크기 압축 유무 인증정보 웹브라우저 유무 , 서버 애플리케이션 캐시 등등 바디 빼고 메타정보 다들어있다. 

**메세지 바디** 

- 실제 전송할 데이터 

> 단순하지만 확장 가능한 HTTP



## HTTP 메서드 

### Get 

- 리소스 조회 
- 쿼리 스트링을 통해서 전달 
- 메세지 바디를 통해서 데이터전달하지만 지원하지 않는 곳이 많음 

### Post 

- 요청 데이터 처리 
- 메세지 바디를 통해 서버로 요청 데이터 전달 
- 신규 리소스 등록 변경된 프로세스 처리 
- 대상 리소스가 리소스의 고유한 의미 체계에 따라 요청에 포함된 표현을 처리하도록 요청함 
- 새 리소스 생성 / 요청 데이터 처리 (프로세스를 처리) 

### put 

- 리소스 대체 
  - 있으면 대체 / 없으면 생성 / 덮어버림 , 완전 대체한다.
  - 클라이언트가 리소스 위치를 알고 URI를 지정한다. 
  - member/100 에다 리소스를 보낼거야!  

### Patch 

- 리소스 부분 변경 

### Delete

- 리소스 제거



### HTTP 메서드 속성 

![image](https://user-images.githubusercontent.com/36434665/127728646-9c68359f-3977-4546-85da-2ede065ad559.png)

#### 안전 

호출해도 리소스를 변경하지 않는다. 

#### 멱등

한번 호출하던 두번호출하던 100번호출하던 결과가 똑같다. 

(외부 요인으로 중간에 리소스가 변경되는 것 까지는 고려하지 않는다.)

#### 캐시가능 

응답 결과 리소스를 캐시해서 사용해도 되는가?



## HTTP메서드 활용 

### Form 데이터 전송 

![image](https://user-images.githubusercontent.com/36434665/127728787-f32081b9-dd76-4a6e-8a46-4e8d5ae32f7b.png)

### HTTP API 데이터 전송 

- 서버 to 서버 
- 웹 앱 클라이언트 (안드로이드 ,아이폰 , ajax 등등)



## HTTP 상태코드 

1xx : 요청이 수신되어서 처리중 

2xx : 요청 정상처리 

3xx: 요청을 완료하려면 추가 행동이 필요

4xx :  클라이언트 오류 잘못된 문법으로 서버가 요청 처리 x

5xx : 서버 오류 , 서버가 정상 요청을 처리하지 못함  



401 Unauthorized > 인증이 필요함 

403 Forbidden 서버가 요청을 이해했지만 승인을 거부함 

404 Not Found 요청 리소스를 찾을 수없음 

500 Internal Server Error 서버 문제로 오류 발생 

503 Service Unavailable  서비스 이용불가



## HTTP 헤더 

HTTP 전송에 필요한 모든 부가정보 

...



### 쿠키 

  HTTP 는 무상태 프로토콜이기때문에 요청 응답 주고받으면 그 이후에 기억하지 못한다. 상태유지 x 



모든 요청에 사용자 정보를 포함해서 보내면된다. 

> 모든 요청에 사용자 정보를 다 포함해서 보내야하는 단점 있음 
>
> 브라우저 껐다 키면 어떻게 ? 

**쿠키** 개념이 도입된다. 

서버에서 `Set-Cooke: user=지니` 정보를 말아서 웹브라우저 쿠키 저장소에 저장을 한다. 

로그인 이후에 다음 페이지 접속할때 쿠키를 뒤져서 무조건 header를 만들어서 보내준다. 

**!! 쿠키정보를 자동으로 포함한다.** 

<u>But! 보안문제가 있을 수 있음</u> 



#### 생명주기 설정 

영속쿠키(지정된 날짜) 세션쿠키 (브라우저 종료시)

#### 도메인 

도메인 지정 가능 

명시 : 명시한문서 기준 도메인 + 서브 도메인 포함 

#### 경로

경로를 포함한 하위 경로 페이지만 쿠키 접근 



#### 보안 

**secure** 

- 쿠키는 http, https 구분 x 
- Secure를 적용하면 https인 경우만 전송 

**HttpOnly**

- XSS공격 방지 
- 자바스크립트에서 접근 불가 (document.cookie)
- HTTP 전송에만 사용 

**SameSite** 

- XSRF공격방지 
- 요청 도메인과 쿠키에 설정된 도메인이 같은 경우에만 쿠키 전송 



## 캐시와 조건부 요청 

### 



























